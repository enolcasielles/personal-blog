---
"": ""
---

# Construyendo un Monorepo en Typescript utilizando pnpm

En este art칤culo voy a explicar lo que es un Monorepo, porqu칠 es interesante utilizarlos para ciertos tipos de proyectos y c칩mo podemos construir uno utilizando pnpm.

### 쯈u칠 es un monorepo?

Un monorepo, como su nombre indica, es un repositorio que contiene m칰ltiples paquetes o partes de un sistema. Pensamos por ejemplo en una arquitectura b치sica de un proyecto web. Podr칤amos tener por un lado un proyecto de front y por otro lado un proyecto de back. Ambos ser칤an totalmente independientes entre s칤, contando con su propio repositorio, c칩digo fuente, dependencias, etc.&#x20;

Por el contrario cuando trabajamos con un monorepo estos 2 proyectos estar칤an bajo el mismo repositorio, seguir칤an siendo totalmente independientes pero tendr칤amos la capacidad de, en los escenarios que queramos, compartir ciertas cosas entre ellos.

### 쮺uando es interesante utilizarlos?

Para ilustrar bien esto vamos a imaginar que el ejemplo que pon칤amos en el apartado anterior tenemos que extenderlo y crear un tercer proyecto. Este proyecto ser치 otra frontal que utilizar치 otro tipo de usuario, por ejemplo un panel de administraci칩n. No ser칤a de extra침ar que este nuevo front comparta componentes de UI con el otro proyecto, 쯨erdad?&#x20;

쮺omo solucionamos esto cuando trabajamos en una arquitectura multirepo? Pues probablemente copiando estos componentes al nuevo proyecto, lo cual nos fuerza a partir de este momento a mantener en 2 sitios componentes que son totalmente iguales.&#x20;

Tendr칤a mucho m치s sentido que esos componentes puedan estar en alg칰n sitio que ambos proyectos puedan utilizarlo, sin necesidad de tenerlos duplicados. Algo como por ejemplo un paquete externo que los 2 proyectos importen. Pues bien, este es el tipo de cosas que un enfoque monorepo nos permite hacer.&#x20;

Cuando los 2 proyectos front viven bajo el mismo monorepo, podemos a침adir un tercer proyecto que se encargue de implementar estos componentes comunes y que ambos proyectos front importen este paquete para utilizarlos.

### 쯄e das otro ejemplo?

Otro ejemplo interesante es cuando quires compartir clases o modelos entre front y back. Frecuentemente ocurre que en el back defines unas clases con los modelos de respuesta que las diferentes llamadas devolver치n y, a su vez, en el front defines otras clases para gestionar la respuesta.&#x20;

Estas clases seguramente sean duplicadas en amos proyectos por lo que tendr칤a mucho m치s sentido si se encuentran un paquete independiente y que ambos proyectos puedan importar. De nuevo un caso que una arquitectura monorepo nos permite implementar y mantener de forma sencilla.

### 쮺칩mo puedo constr\<uir un monorepo?

Vista un poco la teor칤a y la justificaci칩n de porqu칠 es interesante este enfoque vamos a ver c칩mo podemos construir uno en Typescript y utilizando la herramienta pnpm, que es una alternativa a npm que por su funcionamiento encaja mucho mejor para la construcci칩n de un monorepo.

Para empezar vamos a crear un nuevo proyecto vac칤o utilizando pnpm

```txt
pnpm init
```

> Has de tener pnpm instalado en tu m치quina. En su [web oficial](https://pnpm.io/installation) puedes ver como instalarlo

Esto nos crear치 en la carpeta el t칤pico package.json. Hasta este punto lo que tenemos es un proyecto de node est치ndar gestionar por pnpm. Para convertirlo a un proyecto monorepo lo que tenemos que hacer es crear un fichero `pnpm-workspace.yaml` con el siguiente contenido:

```txt
packages:
  - "apps/*"
  - "packages/*"
```

Este fichero lo que hace es especificar en que rutas estar치n los distintos paquetes de nuestro monorepo. En esta caso definimos 2 posibles carpetas,  `app` y `packages` pero esto no es obligatorio. Podemos aprovechar ya para crear estas 2 carpetas en nuestro proyecto, que de momento las dejamos vac칤as. &#x20;

Hacemos esta distinci칩n para diferenciar las aplicaciones de lo que son los paquetes que van a ser utilizados por estas aplicaciones. Para el monorepo no hay distinci칩n alguna entre lo que es una app y lo que es un paquete, la hacemos nosotros por la diferencia conceptual de lo que representa. A partir de ahora cuando hablemos de un paquete ser치 aplicable a cualquiera de los 2 tipos, ya que realmente, es la terminolog칤a utilizada en un monorepo con pnpm.

Como ya hemos comentado cada una de estos paquetes ser치n entidades independientes, nuevos proyectos pnpm que contar치n con su package.json, con su listado de dependencias, scripts personalizados, etc, etc. Pero lo que es importante destacar es que al estar en el monorepo ser치 este quien se encargue de gestionar las dependencias de cada una de ellas. Esto quiere decir que, cuando instalamos una dependencia en alguno de los paquetes ser치 el monorepo quien la instalar치 y quien decidir치 que el alcance de dicha dependencia es para dicho paquete y para ning칰n otro. Ahora bien, 쯤u칠 pasa si instalamos una dependencia en el paquete ra칤z? Recordemos que el paquete ra칤z no deja de ser un proyecto pnpm tambi칠n, por lo que perfectamente se puede instalar algo a este nivel. Pues bien, lo que pasar치 es que dicha dependencia ser치 visible en todos los paquetes.

Por lo general no querremos instalar dependencias en ra칤z pero s칤 que es habitual hacer alguna excepci칩n. Por ejemplo, algo que yo suelo hacer es instalar el typescript y configurar el eslint a este nivel de ra칤z. La raz칩n de hacer esto es que tengo 100% claro que todos los paquetes se va a escribir en typescript y quiero unificar las reglas de escritura de c칩digo en todos ellos. Pero esto de nuevo no tiene porqu칠 ser as칤, es una decisi칩n totalmente de cultura de ingenier칤a del proyecto.

### Instalando dependencias globales

Dicho lo anterior vamos a configurar estas dependicas visibles para todos los paquetes. Para ello simplemente nos tenemos que ubicar en la ra칤z del proyecto ejecutar:

```txt
pnpm install typescript eslint -w
```

Importante destacar el uso de la flag -w. Cuando tratas de instalar algo en la ra칤z del monorepo, por defecto pnpm te lanza un warning para que tengas en cuenta que est치s en ra칤z. Como no es lo habitual instalar dependencias a este nivel considera que puede ser un error y te advierte. Con la flag -w indicas que eres consciente de ello y que quieres instalarlo en ra칤z, evitando que te salte el aviso. Este comportamiento tambi칠n puede ser evitado estableciendo un ajuste en el proyecto, lo veremos m치s adelante.

Una vez hemos hecho esto ya podemos ver como estas 2 dependencias han sido instaladas y aparecen en en el package.json de ra칤z. Vamos a proceder ahora a configurar eslint, para ello vamos a utilizar el configurador que a propia dependencia nos ofrece. Pero antes de hacer esto es importante que tengamos en cuenta algo. Como dec칤amos antes pnpm bloquea las instalaciones a nivel ra칤z si no llevan la flag -w. El configurador de eslint est치 preparado para realizar la instalaci칩n de aquello que necesite con pnpm, pero no la har치 utilizando esta flag -w, por lo que no podr치 finalizar correctamente. 쮺칩mo podemos solucionar esto? Estableciendo un ajuste que le indique a pnpm que ignore este warning. Esto se hace creando un fichero .npmrc e insertando la siguiente l칤nea:

```txt
ignore-workspace-root-check=true
```

Con esto el warning ser치 ignorado y se podr치 instalar en ra칤z sin la flag -w. Procedemos entonces a la configuraci칩n del eslint:

```txt
pnpm eslint --init
```

![](/sample-image.png)

El resultado de este configurador ser치 la instalaci칩n de las dependencias necesarias y la creaci칩n del fichero .eslintrc.json en la ra칤z del proyecto:

```txt
{
    "env": {
        "browser": true,
        "es2021": true,
        "node": true
    },
    "extends": "standard-with-typescript",
    "parserOptions": {
        "ecmaVersion": "latest",
        "sourceType": "module"
    },
    "rules": {
    }
}

```

En este punto tenemos todo listo para empezar a crear paquetes en el monorepo 游

### Creando el primer paquete

Para este ejemplo vamos a crear 2 paquetes de tipo app, uno que ser치 un front en React usando Vite y el otro una Api con express. Adem치s crearemos un tercer paquete que ser치 un proyecto typescript simple, que definir치 unas clases modelo que ambos proyectos compartir치n. Es un proyecto simple pero que nos sirve como ejemplo para entender lo que hemos explicado.

Nos vamos a la carpeta app y creamos un proyecto React usando Vite:

```txt
pnpm create vite@latest front -- --template react-ts
```

Seguimos las instrucciones del configurador para crear el proyecto React con Typescript e instalar todos los paquetes necesatios. Le estamos dando el nombre de front por lo que esto nos crear치 un directorio front dentro de apps. Si tras instalarlo nos vamos a apps/front y hacemos pnpm run dev deber칤amos poder lanzar correctamente el proyecto React en ejecuci칩n. Vamos a hacer ahora algunas modificaciones para adaptarlo mejor al monorepo.

Antes que nada, vamos a decirle a vite que utilice el puerto 3000 para nuestro front, en lugar de una aleatorio como hace por defecto. Nos vamos al vite.config.ts y agregamos el siguiente objeto server:

```txt
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
  }
})
```

A continuaci칩n vamos a adaptar el proyecto un poco mejor para vivir en el monorepo. La instalaci칩n por defecto de Vite configurar치 su propio typescript y eslint, pero como hemos comentado, nosotros queremos usar el del monorepo. Por tanto lo que haremos es desinstalar localmente estas dependencias y eliminar todos los ficheros. Por tanto nos vamos al package.json y eliminamos las siguientes dependecias:

```txt
typescript
eslint
@typescript-eslint/eslint-plugin
@typescript-eslint/parser
```

> En el momento de escribir este art칤culo estas eran las dependencias relacionadas con typescript o eslint que vite instalaba por defecto. Puede que en tu caso esto cambie un poco, aseg칰rate de eliminar todas aquellas que tengan que ver con estas herramientas.

Una vez eliminadas en el package.json ejecutamos pnpm install en apps/front para que la desinstalaci칩n se lleve a cabo. Por 칰ltimo eliminamos el fichero .eslintrc para que no utilice la configuraci칩n de eslint que ah칤 se indica.

Tras hacer esto nuestro proyecto front ya deber칤a coger las reglas de eslint definidas en ra칤z, sigui칠ndolas al 100%. Pero s칤 que es cierto que, seg칰n el tipo de proyecto Typescript en el que estemos, quiz치 nos interese tener alguna configuraci칩n diferente por el tipo de proyecto. Por ejemplo, este paquete front es una aplicaci칩n con React y en este caso es muy com칰n instalar un pligun de eslint para React (eslint-plugin-react) pero no tiene sentido que instalemos este plugin en ra칤z y que nuestro proyecto api tambi칠n est칠 expuesto a lo que dicte este plugin. Por tanto aqu칤 vamos a ver otro tema interesante que es como se puede adaptar la configuraci칩n de eslint para cada proyecto.&#x20;

Primero instalamos a este nivel el paquete con el plugin mencionado

```txt
pnpm install -D eslint-plugin-react
```

Luego creamos de nuevo el fichero .eslintrc.json vac칤o y agregamos en 칠l lo siguiente:

```txt
{
  "extends": [
    "../../.eslintrc", 
    "plugin:react/recommended"
  ],
  "plugins": [
      "react"
  ],
  "rules": {}
}
```

Con esto lo que estamos indicando es, primero que extienda de la configuraci칩n que tenemos definida en ra칤z. Luego que extienda tambi칠n de lo que nos define el plugin de React. Tambi칠n que utilice dicho plugin para que pueda realiza dicha extensi칩n. Por 칰ltimo, al igual que hemos hecho en ra칤z definimos unas reglas personalizadas que por el momento estar치n vac칤as.

&#x20;Si utilizas VSCode y la extensi칩n para eslint, en este momento te deber칤an aparecer errores en tus archivos. Por ejemplo, podemos abrir el App.tsx y ver como hay varios errores de sintaxis. Esto es debido a que ahora la configuraci칩n de eslint es la que viene de Standard, la gu칤a de estilos que decidimos elegir cuando configuramos eslint en ra칤z, extendida adem치s por la del plugin de React que le acabamos de a침adir. Entonces tenemos que adaptar nuestro c칩digo para cumplir con esto. Tenemos 2 opciones para abordarlo: arreglar los errores que nos indica o modificar las reglas definidas. Esto de nuevo ya es una decisi칩n que has de tomar seg칰n como quieras afrontar tu desarrollo.

En mi caso lo que har칠 ser치 una mezcla de ambas opciones. A침adir칠 las siguientes 2 reglas a la configuraci칩n en ra칤z:

```txt
{
  //...
  "rules": {
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/no-floating-promises": "off",
    "@typescript-eslint/no-misused-promises": "off"
  }
}
```

Y a침adir칠 la siguiente a la configuraci칩n del proyecto front:

```txt
{
  //...
  "rules": {
    "react/react-in-jsx-scope": "off"
  }
}
```

Y una vez hecho esto corregir칠 el resto de errores o warnings que eslint me indique.

En este punto tenemos todo listo para crear nuestra App. No vamos a entrar en detalles de la construcci칩n de la aplicaci칩n, que que se escapa totalmente del prop칩sito de este art칤culo. En el repo en github pod칠is ver la implementaci칩n completa, que es una t칤pica app listado de notas utilizando una implementaci칩n muy sencilla para simplemente ilustrar un ejemplo.

### Creando otro paquete para la Api

Ahora que ya hemos visto como crear y adaptar un proyecto al monorepo vamos a hacer lo mismo para la Api. Como hab칤amos dicho implementaremos una Api usando express.

Nos vamos a la carpeta apps y creamos un nuevo directorio llamada api. En este caso no usaremos ning칰n generador. Entramos en la carpeta api y creamos un nuevo proyecto pnpm vac칤o.

```txt
mkdir api && cd api && pnpm init
```

Instalamos las dependencias necesarias

```txt
pnpm add express
pnpm add -D @types/express @types/node nodemon ts-node
```

B치sicamente lo que estamos haciendo es instalar express y como dependencias de desarrollo:

* Los tipos de express y node
* nodemon, que es una herramienta que nos permite f치cilmente hacer que el servidor se recargue con los cambios en los ficheros&#x20;
* ts-node, que b치sicamente digamos que nos permite ejecutar directamente el typescript

Agregamos un fichero nodemon.json en ra칤z para definir como ha de funcionar esta herramienta

```txt
{
  "watch": ["src"],
  "ext": "ts",
  "exec": "ts-node ./src/index.ts"
}
```

Lo que aqu칤 le estamos diciendo es que ha de escuchar a los ficheros en la carpeta src con extensi칩n .ts y que cada vez que se guarde uno de ellos ejecute ts-node en el fichero principal. Con eso lo que conseguimos es ejecutar directamente la api con typescript (ts-node se encarga por debajo de todo) y hacer que se recargue con cada cambio (nodemon se encarga)

Agregamos tambi칠n el fichero tsconfig para indicar como se ha de realizar el transpilado a javascript

```txt
{
  "compilerOptions": {

    "module": "commonjs",
    "target": "ES2020",
    "outDir": "./dist",
    "incremental": true,
    "allowSyntheticDefaultImports": true,
    
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": true,
    
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

  }
}

```

B치sicamente lo que tenemos son 3 grupos de reglas de compilaci칩n. Por un lado le estamos indicando que queremos generar un c칩digo en commonjs modules, utilizando la versi칩n ES2020 y volcando el resultado en el directorio dist. Las reglas incremental y allowSyntheticDefaultImports a true nos permiten mejorar el rendimiento del compilado y hacer el c칩digo m치s compatible con dependencias que no usen un default export . Por otro lado le indicamos que genere todos los mapas necesarios, tanto del javascript al typescript como de las declaraciones de tipos al typescript. Es muy interesante agregar estas reglas ya que permiten al IDE moverte a los ficheros del c칩digo fuente directamente. Y por 칰ltimo algunas reglas de linting.

Por 칰ltimo creamos un script dev en el package.json que simplemente ejecutar치 nodemon

```txt
{
  // ---
  "scripts": {
    //---
    "dev": "nodemon"
  },
}
```

Al igual que hemos dicho con la app de front no vamos a entrar en detalles de la implementaci칩n de la Api. En el repo pod칠is ver que es una simple App express con una base de datos en memoria y 3 definiendo los 3 endpoints que el front require. Nada especial pero que de nuevo nos sirve para llevar a cabo el ejemplo.

### Creando un paquete compartido

Lo siguiente que vamos a hacer es crear un paquete compartido por ambos proyectos, en el que podremos definir cosas que ambos proyectos necesiten compartir. Vamos a llamar a este paquete core y lo crearemos dentro de la carpeta packages.&#x20;

Creamos esta carpeta packages/core y estando en ella creamos de nuevo un proyecto pnpm b치sico.&#x20;

```txt
pnpm init
```

A continuaci칩n creamos el tsconfig para especificar a typescript como ha de realizar el compilado a javascript. Vamos a usar la misma configuraci칩n que en el proyecto api:

```txt
{
  "compilerOptions": {

    "module": "commonjs",
    "target": "ES2020",
    "outDir": "./dist",
    "incremental": true,
    "allowSyntheticDefaultImports": true,
    
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": true,
    
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

  }
}

```

Agregamos los scripts para hacer el build y el dev en el package.json

```txt
{
  // ---
  "scripts": {
    //---
    "build": "tsc",
    "dev": "tsc -w"
  },
}

```

El dev en este caso es mucho m치s sencillo si lo comparamos con el proyecto api. Aqu칤 no tenemos ning칰n servidor en ejecuci칩n ni nada por el estilo. Lo 칰nico que necesitamos es recompilar cuando se guarde cambios.

Y con esto ya tenemos tambi칠n listo este paquete para escribir el c칩digo que necesitemos. Al igual que los anteriores en el repo se puede ver la implementaci칩n completa, que no ser치 nada m치s que una clase Task.

### Scripts en paralelo

Para ir finalizando este art칤culo vamos a ver una cosa interesante de los monorepos que a칰n no hemos comentado, la posibilidad de ejecutar todos los scripts a la vez y en paralelo. Si nos fijamos, los 3 paquetes tienen un script dev. Es muy posible cuando estemos desarrollando que queramos tener levantados estos entornos de desarrollo en los 3 paquetes. Pues pnpm nos permite hacer esto de una forma muy sencilla. Simplemente tenemos que ir al package.json de ra칤z y definir ah칤 el siguiente script dev

```txt
{
  // ---
  "scripts": {
    //---
    "dev": "pnpm run --parallel dev",
  },
}
```

Esto lo que hace es buscar todos los scripts dev que haya en cada uno de los paquetes que conforman el monorepo y ejecutarlos en paralelo.

Otra cosa interesante que nos ofrece pnpm  es la de poder filtrar un script a solo ciertos paquetes. Esto se consigue utilizando el flag --filter. Esto nos da juego a que creemos scripts con las operaciones habituales de desarrollo que m치s necesitemos. Por ejemplo podr칤amos configurar para desde ra칤z poder levantar cada una de las apps por separado o las 2 a la vez pero sin el paquete core

```txt
{ 
  // ---
  "scripts": {
    //---
    "dev": "pnpm run --parallel dev",
    "dev:front": "pnpm run --filter front dev",
    "dev:api": "pnpm run --filter api dev",
    "dev:apps": "pnpm run --filter api --filter front dev"
  },
}
    
```

### Link al repo y fin

Y hasta aqu칤 hemos llegado. Espero que este art칤culo sirva como una introducci칩n para empezar a trabajar con monorepos en typescript usando pnpm y, como ya he dicho varias veces a lo largo del mismo, dejo por aqu칤 en enlace al repo en github donde puedes ver implementado este peque침o ejemplo del uso de un monorepo

LINK