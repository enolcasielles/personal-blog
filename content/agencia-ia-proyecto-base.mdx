---
title: 'Marco de Trabajo para la Creaci√≥n de Agencias de Inteligencia Artificial'
publishedAt: '2024-04-15'
summary: 'Este es el primer art√≠culo de una serie en la que construiremos un marco de trabajo para la construcci√≥n de agencias usando asistentes de IA.'
---

En la actualidad, el avance vertiginoso de la tecnolog√≠a ha colocado a la inteligencia artificial (IA) como un pilar fundamental en diversas industrias, desde la atenci√≥n m√©dica hasta la automatizaci√≥n industrial. Sin embargo, conforme la IA se integra m√°s en nuestros sistemas y procesos cotidianos, surge la necesidad de estructuras m√°s sofisticadas que no solo gestionen tareas individuales, sino que coordinen m√∫ltiples funciones de IA de manera eficiente y efectiva.

Es aqu√≠ donde entra en juego el concepto de las **Agencias de IA**, una idea destinada a fomentar la colaboraci√≥n y la sinergia entre diferentes agentes de IA. Estas agencias no son simplemente conjuntos de algoritmos trabajando en paralelo; son sistemas integrados dise√±ados para que m√∫ltiples asistentes interact√∫en, aprendan y se optimicen mutuamente en tiempo real. Este enfoque no solo ampl√≠a las capacidades de cada agente individual, sino que transforma la manera en que podemos utilizar la IA para abordar problemas complejos y multifac√©ticos.

En este art√≠culo, exploraremos este concepto y plantearemos una soluci√≥n en Typescript que permita la construcci√≥n y gesti√≥n de este tipo de agencias, permitiendo la personalizaci√≥n y la comunicaci√≥n efectiva entre los asistentes.

***

### Motivaci√≥n del proyecto

El mundo de la IA avanza a pasos gigantescos. Cada d√≠a aparecen nuevos modelos, herramientas, estudios de investigaci√≥n, etc. Una de las vertientes que est√° ganando cada vez m√°s fuerza es el concepto de Agentes que interact√∫an entre s√≠. Actualmente existen varios proyectos de c√≥digo abierto que han implementado esta soluci√≥n y que est√°n totalmente a nuestro alcance para ser utilizados. Algunos de los m√°s conocidos son el proyecto [AutoGen](https://microsoft.github.io/autogen/) de Microsoft, el framework [CrewAI](https://www.crewai.com/) o [Agency Swarm](https://github.com/VRSEN/agency-swarm), que es desarrollado por el creador de contenido [VRSEN](https://www.youtube.com/@vrsen), quien est√° sacando v√≠deos continuamente acerca de este enfoque de agencias de IA. El proyecto que desarrollaremos en este tutorial coge muchos de los conceptos que se aplican en este √∫ltimo framework.

Entonces, si sabemos que existen varias herramientas a nuestro alcance, ¬øqu√© sentido tiene desarrollar un "mini framework" que haga algo parecido a estas herramientas? Simplemente, por entender los conceptos y el funcionamiento interno de estas tecnolog√≠as. Si est√°s buscando utilizar una soluci√≥n basada en agencias de IA para tu proyecto te recomiendo encarecidamente que utilices alguna de estas herramientas. Si por el contrario buscas, al igual que yo, entender como se puede construir algo as√≠, te animo a que sigas adelante con el art√≠culo donde veremos y explicaremos todo en detalle.

Dicho lo cual, vamos al l√≠o üöÄ

***

### Concepto de Agencia de IA

Una Agencia de IA es una estructura compleja dise√±ada para coordinar y optimizar la interacci√≥n entre m√∫ltiples asistentes de inteligencia artificial. Este marco de trabajo integra varios componentes clave que permiten una funcionalidad avanzada y una colaboraci√≥n efectiva entre los agentes. A continuaci√≥n, describiremos cada uno de estos componentes y su funci√≥n dentro de la agencia:

#### Agente (Agent)

Un agente es un asistente de IA que realiza tareas espec√≠ficas basadas en una descripci√≥n detallada de sus responsabilidades y las instrucciones de c√≥mo llevarlas a cabo. Cada agente puede equiparse con diversas herramientas personalizadas para expandir su capacidad de acci√≥n m√°s all√° de sus funciones predeterminadas. En nuestra implementaci√≥n, utilizaremos los [asistentes de OpenAI](https://platform.openai.com/docs/assistants/overview).

#### Misi√≥n

La agencia tambi√©n definir√° una misi√≥n, que podemos considerar como unas instrucciones globales. Todo agente ser√° consciente de la misi√≥n de la agencia, para que sepa el objetivo final de lo que hace.

#### Herramienta (Tool)

Las herramientas son extensiones funcionales que permiten a los agentes realizar tareas que exceden sus capacidades iniciales. Estas pueden incluir acciones como enviar correos electr√≥nicos, realizar b√∫squedas en la web o crear y almacenar documentos. Al definir una herramienta, se especifica su funcionalidad, lo que puede hacer y los par√°metros necesarios para su ejecuci√≥n. Toda herramienta contar√° con un m√©todo `run`, donde se implementa la tarea asignada. Finalmente, las herramientas se asignar√°n a los agentes, quienes comprender√°n su funcionamiento y las utilizar√°n cuando sea necesario. Con "utilizarlas" nos referimos a invocar el m√©todo `run` con los par√°metros necesarios.

#### Hilo (Thread)

Para facilitar la comunicaci√≥n entre agentes, se define el concepto de "hilos". Estos son objetos que contienen un agente emisor y otro receptor, funcionando como canales por los cuales los agentes pueden interactuar entre s√≠. Al crear una agencia, adem√°s de especificar los agentes que la conforman, se deber√° definir las comunicaciones que pueden existir entre ellos. Los hilos ser√°n los encargados de registrar esta informaci√≥n.

#### Herramienta TalkToAgent

`TalkToAgent` es una herramienta especial que se cargar√° por defecto en los agentes que lo requieran. Su prop√≥sito es facilitar la iniciaci√≥n de di√°logos entre agentes. Cada agente podr√° y utilizar√° esta herramienta cuando deduzca que debe comunicarse con otro. Para ello, indicar√° como par√°metros el agente destinatario y el mensaje a transmitir. La implementaci√≥n del m√©todo `run` de esta herramienta buscar√° el hilo apropiado que conecta a ambos agentes y enviar√° el mensaje especificado. De esta forma, conseguimos que los agentes tengan la capacidad de comunicarse entre s√≠.

#### Usuario

Dentro de la agencia tambi√©n existe un "agente usuario", una representaci√≥n especial del usuario humano que interact√∫a con la agencia. Este agente no estar√° asociado a un asistente de OpenAI, pero formar√° parte de los hilos que correspondan como emisor, habilitando as√≠ la interacci√≥n del usuario con los diferentes agentes que corresponda.

Estas son las diferentes partes que implementar√° el marco de trabajo. Con ello, para crear una agencia, se comienza por definir y configurar los agentes individuales, especificando su rol particular y las instrucciones para desempe√±ar las tareas que deban realizar. Asimismo, se define la misi√≥n de la agencia. A continuaci√≥n, se asigna a cada agente un conjunto √∫nico de herramientas que complementan y expanden sus capacidades intr√≠nsecas. Posteriormente, se definen las comunicaciones posibles entre los diferentes agentes, habilitando as√≠ los diferentes hilos de comunicaci√≥n que permiten una interacci√≥n entre ellos de manera coordinada, compartiendo informaci√≥n y colaborando en tareas complejas. Tambi√©n se especificar√° con qu√© agentes podr√° comunicarse el usuario. Con todo ello, la agencia est√° lista para empezar a trabajar. Un simple mensaje del usuario a uno de los agentes pondr√° todo en marcha.

***

### Requisitos del Proyecto

Habiendo explicado el concepto de Agencia de IA y lo que se requiere para hacerla funcionar, a continuaci√≥n definiremos algunos requisitos que nuestro software debe cumplir para que podamos utilizarlo y extenderlo de manera robusta y eficiente:

1. **Interfaz Web**: Necesitamos una interfaz web que permita visualizar toda la comunicaci√≥n entre cada Agente y habilite al usuario a comunicarse con aquellos agentes pertinentes.
2. **API Rest**: Debe existir una API Rest que permita consumir la informaci√≥n de la agencia e interactuar con ella. La interfaz web utilizar√° esta API para obtener todos los datos necesarios y enviar los mensajes del usuario.
3. **Separaci√≥n de M√≥dulos**: Es fundamental que los m√≥dulos est√©n completamente separados, diferenciando claramente la implementaci√≥n base de la agencia con la definici√≥n de una agencia espec√≠fica. Un m√≥dulo se encargar√° de implementar las bases, mientras que otro m√≥dulo consumir√° esta implementaci√≥n base y crear√° la agencia. Esto es crucial para permitir la creaci√≥n de diferentes agencias dentro del mismo marco de manera sencilla, lo que nos brindar√° la capacidad de probar diferentes enfoques de manera √°gil y efectiva.
4. **Persistencia de Datos**: En caso de que la aplicaci√≥n se reinicie, es necesario que el estado anterior se mantenga, incluyendo los agentes creados, los hilos, los mensajes, etc. No queremos que cada vez que iniciemos el proyecto, todo se construya desde cero.

***

### Arquitectura del Marco de Trabajo

Para cumplir con los requisitos anteriores, hemos optado por la siguiente arquitectura:

#### Monorepo con Typescript y pnpm

La modularidad es importante y buscamos un entorno de trabajo √°gil y eficiente. Por ello, hemos elegido una arquitectura de monorepo, similar a la que se describe en <a href="/blog/monorepo" target="_blank">este art√≠culo</a>, donde se explica c√≥mo construir un monorepo utilizando herramientas como pnpm. Adem√°s, en este caso nos apoyaremos tambi√©n en la herramienta [turborepo](https://turbo.build/repo) para facilitar la creaci√≥n y gesti√≥n del proyecto.

#### Python o Typescript

Inicialmente, podr√≠a parecer l√≥gico utilizar Python para este proyecto, dado que es el lenguaje dominante en las aplicaciones de procesamiento de lenguaje natural. Sin embargo, despu√©s de un an√°lisis exhaustivo, hemos decidido utilizar Typescript. Las razones de esta decisi√≥n son las siguientes:

* Mi experiencia y dominio en Typescript superan ampliamente a los de Python. Typescript es el lenguaje que utilizo a diario en proyectos reales y de gran alcance, mientras que mi experiencia con Python se limita a peque√±os proyectos de exploraci√≥n.
* Aunque Python es dominante en este √°mbito, Typescript no est√° dejado de lado. Herramientas como [LangChain](https://js.langchain.com/docs/get_started/introduction), [LlamaIndex](https://ts.llamaindex.ai/) y la API de [OpenAI](https://platform.openai.com/docs/introduction) cuentan con soporte para Typescript.
* El uso de Typescript simplifica la implementaci√≥n de la arquitectura propuesta basada en un entorno de monorepo. Integrar Python en este ecosistema nos complicar√≠a las cosas.

A pesar de estas razones, a√∫n tengo dudas y no descarto la posibilidad de migrar el marco de trabajo a Python en el futuro, como una oportunidad para aprender y familiarizarme m√°s con este lenguaje.

#### Interfaz de Usuario con Next.js

La aplicaci√≥n web principal en el monorepo, denominada `web`, se desarrollar√° utilizando [Next.js](https://nextjs.org/). Su funci√≥n principal ser√° facilitar la interacci√≥n del usuario con la agencia y permitirle visualizar de manera organizada la comunicaci√≥n entre los diferentes agentes. En esta primera versi√≥n, la aplicaci√≥n mostrar√° simplemente los "hilos" de comunicaci√≥n entre agentes, lo que permitir√° visualizar los mensajes intercambiados. Adem√°s, cuando el usuario sea el emisor de un hilo, se le dar√° la posibilidad de enviar mensajes al agente receptor. Esta funcionalidad no solo mejora la interactividad, sino que tambi√©n proporciona un seguimiento detallado de las interacciones dentro de la agencia.

#### Paquete `agency`

El n√∫cleo del sistema reside en el paquete `agency`, donde se define la arquitectura principal de la agencia. Este paquete se encarga de implementar toda la funcionalidad de la agencia y de exponer p√∫blicamente las clases o funciones necesarias para la creaci√≥n de las agencias.

Este paquete incluye las siguientes partes:

* **Clases Base:** Se definen las clases fundamentales para la creaci√≥n de un agente (`Agent`) y una herramienta (`Tool`), as√≠ como las clases para los hilos (`Thread`) y los mensajes (`Message`) que facilitan la comunicaci√≥n entre agentes.
* **Clase Agencia:** Se presenta como una clase abstracta. En ella se implementa la funcionalidad necesaria para la ejecuci√≥n de la agencia, pero se delega a quien la extienda los siguientes aspectos:
  * Definici√≥n de los agentes que conforman la agencia.
  * Definici√≥n de las diferentes comunicaciones que puede existir entre los diferentes agentes.
  * Definici√≥n de una carpeta donde se pueda persistir la informaci√≥n de la agencia, garantizando que no se pierda su estado frente a un reinicio de la ejecuci√≥n.
* **API Rest:** Una caracter√≠stica destacada de nuestra agencia es que levantar√° un servidor Express para permitir la interacci√≥n con sus objetos a trav√©s de una API, facilitando as√≠ el acceso a sus datos o la interacci√≥n con ella. La aplicaci√≥n `web` se conectar√° a esta API para comunicarse con la agencia.
* **Server Sent Events:** La aplicaci√≥n `web` necesitar√° poder recibir los mensajes que se van generando y mostrarlos seg√∫n se produzcan. Por ello, adem√°s de la API Rest, necesitamos un mecanismo que permita el env√≠o de datos del servidor al cliente. Para resolver esto, hemos optado por implementar [Server Sent Events](https://developer.mozilla.org/es/docs/Web/API/Server-sent_events/Using_server-sent_events). Cuando la web cargue un hilo, habilitar√° un mecanismo de escucha. Cuando la agencia genere un nuevo mensaje, lo emitir√° al cliente a trav√©s de este mecanismo. De esta forma, mantenemos los mensajes actualizados y en tiempo real en la web.
* **OpenAI:** Como se mencion√≥ anteriormente, para interactuar con el LLM utilizaremos directamente la API de OpenAI. Cada agente crear√° un asistente de OpenAI a trav√©s del cual se comunicar√° con otros agentes.

#### Implementaci√≥n de la Agencia

Con el paquete `agency` disponible, solo nos queda utilizarlo para definir las agencias que deseemos. Para ello, habilitaremos una nueva aplicaci√≥n en el monorepo que llamaremos `back`, la cual tendr√° una dependencia con este paquete `agency`. En este art√≠culo, no profundizaremos en esta parte, ya que nuestro objetivo es explicar los fundamentos para la creaci√≥n de las agencias, no su definici√≥n detallada. En art√≠culos posteriores, utilizaremos esta base para crear diferentes agencias capaces de resolver problemas reales.

***

### Implementaci√≥n de la app `web`

No profundizaremos en la explicaci√≥n de esta parte en particular. Se trata de un proyecto Next muy sencillo que consta de una √∫nica pantalla. En esta pantalla, se presenta un men√∫ lateral que lista todos los hilos de comunicaci√≥n, mientras que a la derecha se muestran los mensajes del hilo seleccionado. Este proyecto utiliza un servicio para realizar llamadas a la API y obtener los datos necesarios.

Cuando la pantalla de un hilo se carga, se verifica si el usuario forma parte de dicho hilo. En caso afirmativo, se habilita un campo de texto en la parte inferior junto con un bot√≥n de enviar, lo que permite al usuario enviar mensajes en ese hilo espec√≠fico.

La implementaci√≥n se encuentran disponibles en el repositorio de GitHub mencionado al final del art√≠culo. Sin embargo, dado que este tema se aleja del prop√≥sito principal de este art√≠culo, considero que no es necesario profundizar en los detalles de esta implementaci√≥n.

***

### Implementaci√≥n del paquete `agency`

Vamos a examinar en detalle c√≥mo se implementa el n√∫cleo de una agencia, as√≠ como las diferentes partes que lo componen y c√≥mo se relacionan entre s√≠.

#### Clase User

La clase `User` representa una entidad con capacidad de comunicaci√≥n en el sistema. Esto puede ser tanto un agente de IA como el usuario real que utiliza la agencia. Los agentes extienden esta clase `User`, que es un modelo simple con propiedades `id` y `name`.

```tsx
export class User {
  constructor(
    public id: string,
    public name: string,
  ) {}
}

```

El usuario real se representa como una instancia de esta clase.

#### Agent

La clase `Agent` sirve como base para la creaci√≥n de los agentes que componen la agencia. Esta clase tiene propiedades para definir las diferentes caracter√≠sticas de un agente, como su nombre, instrucciones o las herramientas que se le asignan. Adem√°s, cuenta con un m√©todo principal que llamamos `init`, donde se lleva a cabo la inicializaci√≥n del asistente asociado en OpenAI.

```tsx
  async init() {
    if (this.id) {
      let openAiAssistant = await openaiClient.beta.assistants.retrieve(
        this.id,
      );
      const shouldUpdate = this.shouldUpdate(openAiAssistant);
      if (shouldUpdate) {
        openAiAssistant = await openaiClient.beta.assistants.update(
          this.id,
          this.generateBody() as AssistantUpdateParams,
        );
      }
      this.assistant = openAiAssistant;
      if (shouldUpdate) this.delegate.onUpdateAgent(this);
    } else {
      this.assistant = await openaiClient.beta.assistants.create(
        this.generateBody() as AssistantCreateParams,
      );
      this.id = this.assistant.id;
    }
  }
```

Este m√©todo determina si el agente tiene asignado un ID, lo que indica si ya existe en OpenAI. Si existe, se recupera; de lo contrario, se crea uno nuevo. Adem√°s, emplea el m√©todo privado `shouldUpdate` para verificar si es necesario actualizarlo. Esto es crucial para garantizar que los cambios realizados en el agente, como la actualizaci√≥n de sus instrucciones, se reflejen en el asistente de OpenAI. Del mismo modo tambi√©n asegura que no se est√©n creando nuevos asistentes cada vez que la aplicaci√≥n arranca.

Una caracter√≠stica destacada de la clase `Agent` es su uso del patr√≥n *Observer* para notificar a otros objetos sobre ciertos eventos. Espec√≠ficamente, se notifica cuando se actualiza el agente en OpenAI. M√°s adelante, veremos como la clase `Agency` actuar√° como el delegado u observador, utilizando este evento para llevar a cabo acciones espec√≠ficas.

#### Message

Una parte sencilla pero importante de nuestro sistema es la clase `Message`, que representa cada uno de los mensajes que se generan durante la ejecuci√≥n. Es una clase modelo con las propiedades que queremos registrar.

```tsx
export class Message {
  id: string;
  date: Date;
  type: MessageType;
  content: string;
  from: User;
  to: User;

  constructor({ id, date, type, content, from, to }: Props) {
    this.id = id;
    this.date = date;
    this.type = type;
    this.content = content;
    this.from = from;
    this.to = to;
  }
}
```

#### Tool

Definimos la clase `Tool` para representar las diferentes herramientas que se asignan a los agentes para dotarles de funcionalidades. Por un lado define las propiedades que OpenAI necesita para la creaci√≥n de la herramienta: el nombre, la descripci√≥n y la definici√≥n de los par√°metros que puede recibir. Por otro lado define un m√©todo abstracto `run`que ser√° el que cada `Tool` deber√° implementar para ejecutar las tareas que deba realizar. Como veremos m√°s adelante, el sistema estar√° preparado para que, cuando un agente deduzca que una herramienta ha de ser ejecutada, se invoque este m√©todo `run` en ella con los par√°metros que el agente nos indique.

```tsx
export abstract class Tool {
  name: string;
  description: string;
  parameters: any;

  constructor({ name, description, parameters }: ToolParams) {
    this.name = name;
    this.description = description;
    this.parameters = parameters;
  }

  abstract run(parameters: RunProps): Promise<string>;
}
```

#### Thread

La clase `Thread` es fundamental en el sistema, ya que facilita la comunicaci√≥n entre agentes permitiendo el intercambio de mensajes entre ellos. Esta clase es responsable de interactuar con OpenAI para enviar mensajes y gestionar las respuestas recibidas.

Destacan varias propiedades en esta clase, entre las que se encuentran `senderAgent` y `recipientAgent`, que son objetos que representan los dos agentes (o usuarios) involucrados en la comunicaci√≥n. Adem√°s, cuenta con la propiedad `messages`, que es una lista de objetos de tipo `Message` y se utiliza para almacenar los mensajes generados durante la comunicaci√≥n.

En cuanto a los m√©todos, por un lado tenemos `init`, el cual se encarga de inicializar el `Thread` en OpenAI. Al igual que con los agentes, este m√©todo utiliza la propiedad `id` para determinar si el registro ya existe y solo necesita ser recuperado, o si, por el contrario, no existe y debe crearse en OpenAI. Veremos m√°s adelante como `Agency` crear√° estos objetos `Thread` con id o no, para indicar si ya existe o no en funci√≥n de la informaci√≥n que tenga en su capa de persistencia.

```tsx
  async init() {
    if (this.id) {
      this.thread = await openaiClient.beta.threads.retrieve(this.id);
    } else {
      this.thread = await openaiClient.beta.threads.create();
      this.id = this.thread.id;
    }
  }
```

Por otro lado tenemos el m√©todo `send`. Este m√©todo es el que se llama cada vez que se debe enviar un mensaje a `recipientAgent`.

```tsx
  async send(message: string, retries: number = 1): Promise<string> {
    if (!this.recipientAgent.id) throw new Error("Recipient agent not set");
    if (!this.thread) await this.init();
    await openaiClient.beta.threads.messages.create(this.id, {
      role: "user",
      content: message,
    });
    this.run = await openaiClient.beta.threads.runs.create(this.id, {
      assistant_id: this.recipientAgent.id,
    });
    this.addNewMessage(MessageType.Text, message);
    while (true) {
      await this.waitUntilDone();
      if (this.run.status === "completed") {
        const _message = await this.extractMessage();
        this.addNewMessage(MessageType.Text, _message, true);
        return message;
      } else if (this.run.status === "requires_action") {
        await this.processAction();
      } else {
        const err = "Run failed: " + this.run.status;
        console.log(err);
        if (retries < MAX_RETRIES) {
          console.log("Retrying in 30s...");
          await new Promise((resolve) => setTimeout(resolve, 30000));
          return this.send(message, retries + 1);
        }
        const _message = this.generateFailedMessage();
        this.addNewMessage(MessageType.Text, _message, true);
        return _message;
      }
    }
  }
```

Veamos detalladamente el proceso que se lleva a cabo aqu√≠. En primer lugar, verificamos que el agente receptor est√© correctamente inicializado. Luego, comprobamos si el hilo est√° inicializado; en caso contrario, lo inicializamos. A continuaci√≥n, creamos el mensaje en el asistente de OpenAI y posteriormente creamos el objeto `run`, proporcionado por OpenAI, que nos permite controlar el env√≠o del mensaje y la recepci√≥n de la respuesta.

Seguidamente, a√±adimos el mensaje al listado y comenzamos un bucle infinito para controlar la respuesta. Dentro de este bucle, primeramente utilizamos un m√©todo privado para verificar el estado del `run` y continuamos √∫nicamente cuando tenga un estado adecuado.

```tsx
  private async waitUntilDone() {
    while (["queued", "in_progress", "cancelling"].includes(this.run.status)) {
      await new Promise((resolve) => setTimeout(resolve, 1000));
      this.run = await openaiClient.beta.threads.runs.retrieve(
        this.id,
        this.run.id,
      );
    }
  }
```

Cuando el `run` alcance un estado que nos permita manejar la respuesta, actuaremos en consecuencia. Si el estado es `completed`, sabemos que hemos recibido una respuesta definitiva del asistente, por lo que podemos procesarla, generar un nuevo mensaje y concluir esta ejecuci√≥n. Para procesar la respuesta, nos apoyamos en otro m√©todo privado llamado `extractMessage`.

```tsx
  private async extractMessage() {
    const messages = await openaiClient.beta.threads.messages.list(this.id);
    const content = messages.data[0].content[0];
    if (content.type === "text") {
      return content.text.value;
    } else {
      throw new Error(
        "Framework does not support messages different than text yet.",
      );
    }
  }
```

Sin embargo, los asistentes de OpenAI no siempre proporcionan una respuesta directa. Si han sido equipados con herramientas y durante su ejecuci√≥n determinan que necesitan usar alguna de ellas, nos lo indicar√°n estableciendo en el `run` un estado con valor `requires_action` y nos proporcionar√°n todo lo necesario para llevar a cabo la acci√≥n. Cuando esto suceda, utilizaremos otro m√©todo privado llamado `processAction` para gestionar dicha acci√≥n.

```tsx
  private async processAction() {
    const toolsToExecute =
      await this.run.required_action.submit_tool_outputs.tool_calls;
    const toolsResults = [];
    for (const toolToExecute of toolsToExecute) {
      this.addNewMessage(
        MessageType.Action,
        `Acci√≥n requerida. Ejecutando la tool ${toolToExecute.function.name} con par√°metros ${toolToExecute.function.arguments}`,
        true,
      );
      const toolName = toolToExecute.function.name;
      const tool = this.recipientAgent.tools.find((t) => t.name === toolName);
      const toolResult = tool
        ? await tool.run({
            ...JSON.parse(toolToExecute.function.arguments),
            callerAgent: this.recipientAgent,
          })
        : "ERROR: no existe ninguna herramienta con el nombre que has indicado. Int√©ntalo de nuevo con el nombre correcto. La lista de herramientas disponibles es la siguiente: " +
          this.recipientAgent.tools.map((t) => t.name).join(", ");
      this.addNewMessage(
        MessageType.Action,
        `${toolToExecute.function.name} completada. Respuesta: ${toolResult.toString()}`,
        true,
      );
      toolsResults.push({
        tool_call_id: toolToExecute.id,
        output: toolResult.toString(),
      });
    }
    this.run = await openaiClient.beta.threads.runs.submitToolOutputs(
      this.id,
      this.run.id,
      {
        tool_outputs: toolsResults,
      },
    );
  }
```

Este m√©todo b√°sicamente extrae la informaci√≥n de la respuesta para determinar qu√© herramientas deben ejecutarse. A continuaci√≥n recorre cada una de estas herramientas y realiza las siguientes acciones:

* Guarda el mensaje para registrar que se va a ejecutar una herramienta.
* Busca esta herramienta a partir de su nombre dentro de las herramientas del agente y la ejecuta para obtener un resultado. En caso de que no encuentre la herramienta, directamente genera un resultado de error.&#x20;
* Guarda un nuevo mensaje para registrar el resultado de la invocaci√≥n de dicha herramienta

Cuando finalice la invocaci√≥n de todas las herramientas indicadas por el agente, se le env√≠a los resultados obtenidos a OpenAI, para que el asistente sepa como ha de continuar su ejecuci√≥n. Este √∫ltimo paso tambi√©n actualizar√° el objeto `run`, lo que har√° que el bucle principal pueda continuar su proceso.

Volviendo al bucle principal, tambi√©n gestionamos el caso en el que el estado no sea ni `completed` ni `requires_action`. En este caso, OpenAI nos indica que ha ocurrido alg√∫n tipo de error. A veces, esto puede deberse simplemente a un mal funcionamiento de la API en ese momento. Por eso, establecemos un mecanismo de reintento. Cuando llegamos a esta parte del c√≥digo, hacemos una pausa de 30 segundos en la ejecuci√≥n y volvemos a intentar el proceso desde el principio. Si despu√©s de 3 intentos el problema persiste, finalizamos con un mensaje manual de error.

Para concluir, es importante mencionar que al igual que la clase `Agent`, la clase `Thread` tambi√©n utiliza un patr√≥n *Observer* para informar a un delegado cuando se a√±ade un nuevo mensaje. Esto se realiza a trav√©s de la interfaz `ThreadDelegate`. El m√©todo privado `addNewMessage` utiliza este delegado para enviarle el mensaje que se acaba de registrar. M√°s adelante, veremos c√≥mo la clase `Agency` se registrar√° como delegado y ejecutar√° ciertas acciones cuando se produzca este evento.

```tsx
  private addNewMessage(type: MessageType, content: string, inverse = false) {
    const message: Message = {
      id: Math.random().toString(),
      date: new Date(),
      type,
      content,
      from: inverse ? this.recipientAgent : this.senderAgent,
      to: inverse ? this.senderAgent : this.recipientAgent,
    };
    this.messages.push(message);
    this.delegate.onNewMessage(this, message);
  }
```

Podemos concluir este apartado mencionando que la clase `Thread` es una pieza clave en nuestro sistema, ya que es donde reside toda la interacci√≥n con OpenAI para el env√≠o de mensajes, la gesti√≥n de respuestas y la invocaci√≥n de posibles herramientas.

#### Api

Como ve√≠amos anteriormente, un requisito que tenemos es el de habilitar la exposici√≥n de los datos de la agencia y permitir la interacci√≥n con ella a trav√©s de una API Rest. La clase `Api` asume esta responsabilidad.

Esta clase se apoya en la librer√≠a [Express](https://expressjs.com/) para crear una simple API Rest con los endpoints que necesitamos. A trav√©s del constructor obligamos a que reciba la instancia de la clase `Agency`, que la usar√° para acceder a los datos de la misma. Tambi√©n permitimos desde el constructor elegir el puerto en el que se quiere exponer esta API.&#x20;

La clase cuenta con un m√©todo `init`en el que se inicializar√° express y se definir√°n los diferentes endpoints.

```tsx
  async init() {
    const agency = this.agency;

    const app = express();
    app.use(express.json());
    app.use(sseMiddleware);
    app.use(cors());

    app.get("/ping", async (_: Request, res: Response) => {
      try {
        res.send({ hello: "world" });
      } catch (err) {
        res.status(500).send({ error: err });
      }
    });

    app.get("/info", async (_: Request, res: Response) => {
      try {
        res.send({
          name: agency.name,
          mission: agency.mission,
          agents: agency.agents.map((agent) => ({
            name: agent.name,
            id: agent.id,
          })),
        });
      } catch (err) {
        res.status(500).send({ error: err });
      }
    });

    //-------Resto de endpoints-------

  }
```

Algo a destacar en esta clase es la propiedad `clients`, que ser√° un listado de objetos `SseClient` , clase que explicamos enseguida. Esta es la forma que conseguimos habilitar una comunicaci√≥n basada en [Server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events). Anteriormente explicamos que esto es importante para poder enviar al cliente los mensajes que se vayan generando y que pueda actualizar la interfaz con cada evento. Para esto nos apoyamos en la librer√≠a [express-sse-middleware](https://www.npmjs.com/package/express-sse-middleware) que habilita un middleware de Express para el uso de esta tecnolog√≠a. En el anterior `init` se puede ver como se inicializa este middleware. Para usar esta funcionalidad dotamos a la API de un endpoint que se encarga de crear un nuevo `SseClient`.

```tsx
    app.get(
      "/threads/:threadId/sseClient",
      async (req: Request, res: Response) => {
        try {
          const { threadId } = req.params;
          const sseClient = new SseClient(threadId, res.sse());
          this.clients.push(sseClient);
          req.on("close", () => {
            this.removeSseClient(threadId);
          });
        } catch (err) {
          res.status(500).send({ error: err });
        }
      },
    );
```

La clase `SseClient` simplemente registra el id del `Thread` al que est√° conectado el cliente y el propio objeto que nos permite la comunicaci√≥n, obtenido a partir de `res.sse()`

```tsx
export class SseClient {
  private client: any;

  constructor(
    public threadId: string,
    client: any,
  ) {
    this.client = client;
  }

  send(data: any) {
    this.client.send(JSON.stringify(data));
  }

  close() {
    this.client.close();
  }
}
```

La clase `SseClient` cuenta con 2 m√©todos, uno para enviar un mensaje al cliente y otro para cerrar la comunicaci√≥n.

Volviendo a la clase `Api` , definimos otro m√©todo `sendMessage`, que recibiendo el id de un `Thread` y el objeto `Message` se encarga de analizar si existe alg√∫n cliente conectado a ese hilo y, en ese caso, enviarle el mensaje. Este m√©todo es utilizado por la clase `Agency` para informar de los nuevos mensajes que se generan.

```tsx
  sendMessage(threadId: string, message: Message) {
    if (!this.clients) return;
    const sseClient = this.clients.find(
      (client) => client.threadId === threadId,
    );
    if (!sseClient) return;
    sseClient.send({
      date: message.date,
      type: message.type,
      content: message.content,
      from: message.from.name,
      to: message.to.name,
    });
  }
```

Por √∫ltimo, la clase `Api` cuenta con un m√©todo `removeSseClient`, responsable de limpiar una conexi√≥n. Este m√©todo es ejecutado cuando el servidor detecte que un cliente finaliza la comunicaci√≥n, liberando as√≠ los recursos que dejan de ser √∫tiles. En el endpoint `/threads/:threadId/sseClient`que ve√≠amos un poco m√°s arriba, se puede ver como se llama a este m√©todo cuando se detecta un cierre en la conexi√≥n.

```tsx
  removeSseClient(threadId: string) {
    if (!this.clients) return;
    const sseClient = this.clients.find(
      (client) => client.threadId === threadId,
    );
    if (!sseClient) return;
    sseClient.close();
    this.clients = this.clients.filter(
      (client) => client.threadId !== threadId,
    );
  }
```

#### Agency

En este punto, hemos delineado las diferentes partes clave que definen nuestra agencia. Ahora solo nos queda entender c√≥mo ponerlas en funcionamiento todas juntas. La clase `Agency` asumir√° esta responsabilidad.

La clase `Agency` ser√° una clase abstracta que tendr√° propiedades y m√©todos propios para permitir la ejecuci√≥n correcta de la agencia, pero delegar√° a quien la utilice los detalles de la definici√≥n de dicha agencia. Esto es crucial y veremos por qu√©. Esta clase se encargar√° de tareas como iniciar los agentes, los hilos, persistir los datos, etc. Sin embargo, no queremos que esta clase tome decisiones sobre qu√© agentes conforman la agencia o d√≥nde se persisten los datos. Estas son responsabilidades de la aplicaci√≥n que utilice esta clase. Por esta raz√≥n, definimos 3 m√©todos abstractos:

* El m√©todo `getAgents`, que deber√° devolver el listado de agentes deseado.
* El m√©todo `getAgentCommunications`, que, al pasarle un agente, deber√≠a indicarnos con qu√© otros agentes puede comunicarse.
* El m√©todo `getDBPath`, que deber√° devolver la ruta de una carpeta en la que la agencia podr√° guardar la informaci√≥n necesaria para asegurar la persistencia de datos. Esto es clave ya que as√≠ esta clase gestiona la persistencia de datos pero el espacio en el que se almacenan es responsabilidad de quien la utilice.

Continuamos con las propiedades de esta clase. Por un lado, tenemos el nombre y la misi√≥n de la agencia: `name` y `mission`. Estas propiedades se pueden definir desde el constructor. La clase inicializar√° una instancia de `User` para representar al usuario que utiliza la agencia. Adem√°s, contar√° con propiedades para registrar el listado de agentes (`Agent`) o hilos (`Thread`). Tambi√©n contar√° con una propiedad para registrar la ruta en la que se persisten los datos, `dbPath`, y una instancia de la clase `Api`.

```tsx
export abstract class Agency implements ThreadDelegate, AgentDelegate {
  name: string;
  mission: string;

  user: User;
  agents: Array<Agent>;
  threads: Array<Thread>;
  api: Api;
  dbPath: string;

  constructor({ name, mission }: AgencyParams) {
    this.name = name;
    this.mission = mission;
    this.user = new User("user", "User");
  }

  abstract getAgents(): Agent[];
  abstract getAgentCommunications(agent: User): Agent[];
  abstract getDBPath(): string;

  /**
   * --- Methods ---
   */

}
```

En cuanto a los m√©todos, comenzamos con `initApi`, que simplemente se encarga de inicializar la instancia de la clase `Api`.

```tsx
  async initApi(port: number) {
    this.api = new Api(this, port);
    await this.api.init();
  }
```

Continuamos con el m√©todo `run`. Aqu√≠ ser√° donde se lleva a cabo la definici√≥n de todas las entidades que se necesita.

```tsx
  async run() {
    this.dbPath = this.getDBPath();
    this.agents = this.getAgents();
    if (!this.agents || this.agents.length === 0)
      throw new Error(
        "You can't init without defining any agents. User will talk to first defined agent",
      );
    for (const agent of this.agents) {
      agent.id = this.getSavedAgentId(agent);
      agent.setDelegate(this);
      if (this.mission)
        agent.instructions = `${this.mission}\n\n${agent.instructions}`;
      this.addCommonTools(agent);
      await agent.init();
    }
    this.threads = [];
    for (const agent of [this.user, ...this.agents]) {
      const recipientAgents = this.getAgentCommunications(agent);
      for (const recipientAgent of recipientAgents) {
        const thread = new Thread({
          id: this.getSavedThreadId(agent, recipientAgent),
          senderAgent: agent,
          recipientAgent,
          delegate: this,
        });
        thread.messages = this.getSavedMessages(thread.id);
        await thread.init();
        this.threads.push(thread);
      }
    }
    this.saveAgentsAndThreads();
  }
```

B√°sicamente lo que este m√©todo hace es inicializar los agentes y los hilos. Como comentamos, nos apoyamos en los m√©todos abstractos para que la aplicaci√≥n nos de los detalles. Tambi√©n vemos como se utilizan m√©todos privados para comprobar si cierto agente o hilo existe ya o no, lo cual permitir√° decidir si ha de crearse desde cero o usar el existente. Lo mismo para la carga de los mensajes generados en anteriores ejecuciones.

A continuaci√≥n vamos a ver los m√©todos que se utilizan para implementar el mecanismo de persistencia de datos. Como veremos estamos guardando ficheros JSON en la carpeta que la clase hija nos ha especificado. Este mecanismo de persistencia de datos es **muy b√°sico y poco robusto.** Ser√≠a mucho m√°s interesante implementar una base de datos que registre esta informaci√≥n, pero por simplicidad se ha optado por esta soluci√≥n. Una muy clara mejora de este proyecto es la migraci√≥n de esta parte a un mecanismo basado en una base de datos convencional.

```tsx
  private getSavedAgentId(agent: Agent): string {
    const agentsDataStr = this.readFileContentOrCreate(
      path.resolve(this.dbPath, "./agents.json"),
    );
    const agentsData = agentsDataStr ? JSON.parse(agentsDataStr) : [];
    const agentData = agentsData.find((a: any) => a.name === agent.name);
    return agentData ? agentData.id : null;
  }
```

```tsx
  private getSavedThreadId(senderAgent: User, recipientAgent: User): string {
    const threadsDataStr = this.readFileContentOrCreate(
      path.resolve(this.dbPath, "./threads.json"),
    );
    const threadsData = threadsDataStr ? JSON.parse(threadsDataStr) : [];
    const threadData = threadsData.find(
      (t: any) =>
        t.senderAgent === senderAgent.id &&
        t.recipientAgent === recipientAgent.id,
    );
    return threadData ? threadData.id : null;
  }
```

```tsx
  private getSavedMessages(threadId: string): Message[] {
    const messagesDataStr = this.readFileContentOrCreate(
      path.resolve(this.dbPath, "./messages.json"),
    );
    const messagesData = messagesDataStr ? JSON.parse(messagesDataStr) : [];
    const messages = messagesData
      .filter((m: any) => m.threadId === threadId)
      .map((message: any) => {
        const fromUser = message.from === this.user.id;
        const toUser = message.to === this.user.id;
        return new Message({
          id: message.id,
          date: new Date(message.date),
          type: message.type,
          content: message.content,
          from: fromUser
            ? this.user
            : this.agents.find((a) => a.id === message.from),
          to: toUser ? this.user : this.agents.find((a) => a.id === message.to),
        });
      });
    return messages;
  }
```

Cuando se ha completado la inicializaci√≥n de todas las entidades, invocamos al m√©todo `saveAgentsAndThreads`, lo cual persiste el estado actual de los agentes e hilos, asegurando que tengamos siempre todo correctamente sincronizado.

```tsx
  private saveAgentsAndThreads(): void {
    const agentsData = this.agents.map((agent) => ({
      name: agent.name,
      id: agent.id,
    }));
    fs.writeFileSync(
      path.resolve(this.dbPath, "./agents.json"),
      JSON.stringify(agentsData),
    );
    const threadsData = this.threads
      .filter((t) => t.id !== null)
      .map((t) => ({
        id: t.id,
        recipientAgent: t.recipientAgent.id,
        senderAgent: t.senderAgent.id,
      }));
    fs.writeFileSync(
      path.resolve(this.dbPath, "./threads.json"),
      JSON.stringify(threadsData),
    );
  }
```

Cuando estos m√©todos `initApi` y `run` se hayan ejecutado, la agencia estar√° totalmente lista para ser utilizada. Ahora entra en juego el m√©todo `processUserMessage`, que ser√° el que se llamar√° cuada vez que un usuario se comunique con un agente.&#x20;

```tsx
  async processUserMessage(threadId: string, message: string): Promise<string> {
    const thread = this.threads.find((thread) => thread.id === threadId);
    if (!thread) throw new Error("Thread not found");
    if (thread.senderAgent !== this.user)
      throw new Error("User can't send message to this thread");
    return await thread.send(message);
  }
```

Simplemente recupera el `Thread` y ejecuta su m√©todo `send`.

Esta clase `Agency` tambi√©n expone los m√©todos `getThread` y `getAgentByName`, que ser√°n utilizados por `Api` para obtener un hilo o un agente.

```tsx
  getThread(senderAgentName: string, recipientAgentName: string) {
    return this.threads.find(
      (thread) =>
        thread.senderAgent.name === senderAgentName &&
        thread.recipientAgent.name === recipientAgentName,
    );
  }

  getAgentByName(agentName: string) {
    return this.agents.find((agent) => agent.name === agentName);
  }
```

Continuamos con la implementaci√≥n de las interfaces. ¬øRecord√°is cuando explicamos las clases `Agent` o `Thread` y mencionamos que utilizaban un patr√≥n *Observer*? Pues bien, esta clase `Agency` ser√° la responsable de implementar esta funcionalidad y registrarse como delegado. Si nos fijamos en el m√©todo `run`, cuando se crea un agente o un hilo, veremos que se env√≠a la instancia de esta clase `Agency` a la propiedad `delegate`. Adem√°s, en la definici√≥n de la clase `Agency`, especificamos que implementar√° los m√©todos de `ThreadDelegate` y `AgentDelegate`. Por √∫ltimo, en la parte inferior de la clase, llevamos a cabo estas implementaciones. B√°sicamente, utilizamos este mecanismo para poder persistir los datos cuando un agente se actualiza o un hilo guarda un nuevo mensaje.

```tsx
  /**
   * ThreadDelegate implementation
   */
  onNewMessage(thread: Thread, message: Message): void {
    if (!this.api) return;
    this.api.sendMessage(thread.id, message);
    const messagesDataStr = this.readFileContentOrCreate(
      path.resolve(this.dbPath, "./messages.json"),
    );
    const messages = messagesDataStr ? JSON.parse(messagesDataStr) : [];
    messages.push({
      id: message.id,
      threadId: thread.id,
      date: message.date.toISOString(),
      type: message.type,
      content: message.content,
      from: message.from.id,
      to: message.to.id,
    });
    fs.writeFileSync(
      path.resolve(this.dbPath, "./messages.json"),
      JSON.stringify(messages),
    );
  }
```

```tsx
  /**
   * AgentDelegate implementation
   */
  onUpdateAgent(agent: Agent): void {
    const agentsDataStr = fs.readFileSync(
      path.resolve(this.dbPath, "./agents.json"),
      "utf-8",
    );
    const agentsData = JSON.parse(agentsDataStr);
    const agentData = agentsData.find((a: any) => a.id === agent.id);
    agentData.name = agent.name;
    fs.writeFileSync(
      path.resolve(this.dbPath, "./agents.json"),
      JSON.stringify(agentsData),
    );

    const threadsDataStr = fs.readFileSync(
      path.resolve(this.dbPath, "./threads.json"),
      "utf-8",
    );
    const threadsData = JSON.parse(threadsDataStr);
    const threadsDataFiltered = threadsData.filter(
      (t: any) => t.senderAgent !== agent.id && t.recipientAgent !== agent.id,
    );
    fs.writeFileSync(
      path.resolve(this.dbPath, "./threads.json"),
      JSON.stringify(threadsDataFiltered),
    );

    const messagesDataStr = fs.readFileSync(
      path.resolve(this.dbPath, "./messages.json"),
      "utf-8",
    );
    const messagesData = JSON.parse(messagesDataStr);
    const messagesDataFiltered = messagesData.filter(
      (m: any) => m.from !== agent.id && m.to !== agent.id,
    );
    fs.writeFileSync(
      path.resolve(this.dbPath, "./messages.json"),
      JSON.stringify(messagesDataFiltered),
    );
  }
```

Por √∫ltimo, hay un detalle importante que hemos pasado por alto y que vale la pena resaltar: el m√©todo privado `addCommonTools`. Este m√©todo se encarga de asignar a un agente las herramientas que deseemos darle por defecto. En el m√©todo `run`, al inicializar el agente, llamamos a este m√©todo para cargar estas herramientas. Por el momento, solo contamos con una herramienta com√∫n, llamada `TalkToAgent`. En la siguiente secci√≥n, la explicaremos en detalle, pero en resumen, esta herramienta permite que los agentes se comuniquen entre s√≠. Por esta raz√≥n, solo cargaremos esta herramienta en los agentes que pueden comunicarse con otros, es decir, aquellos cuya lista de `recipientAgents` no est√© vac√≠a.

```tsx
  private addCommonTools(agent: Agent) {
    const recipientAgents = this.getAgentCommunications(agent);
    if (recipientAgents.length > 0) {
      agent.addTool(
        new TalkToAgent({
          senderAgent: agent,
          agency: this,
        }),
      );
    }
  }
```

#### TalkToAgent

La clase `TalkToAgent` es una herramienta especializada dise√±ada para facilitar la comunicaci√≥n directa y sincr√≥nica entre agentes dentro de la agencia. Su objetivo principal es permitir que un agente env√≠e un mensaje directamente a otro agente espec√≠fico y reciba una respuesta exclusiva de ese agente.

Al usar esta herramienta, un agente puede enviar un mensaje utilizando los siguientes par√°metros:

* `recipient`: Especifica el nombre del agente destinatario al que se enviar√° el mensaje.
* `message`: Describe la tarea que el agente destinatario debe completar.

Creamos esta clase extendiendo de `Tool`y especificando su nombre, descripci√≥n y los par√°metros que utiliza. Tambi√©n obligamos a que se env√≠e el agente que la est√° utilizando y la instancia de la agencia, ya que necesitaremos estos objetos en el `run`

```tsx
export class TalkToAgent extends Tool {
  senderAgent: Agent;
  agency: Agency;
  constructor({ senderAgent, agency }: Props) {
    super({
      name: "TalkToAgent",
      description:
        "Utiliza esta herramienta para facilitar la comunicaci√≥n directa y sincr√≥nica entre agentes especializados dentro de la agencia. Cuando env√≠es un mensaje usando esta herramienta, recibir√°s una respuesta exclusivamente del agente destinatario designado. Para continuar el di√°logo, invoca esta herramienta nuevamente con el agente destinatario deseado y tu mensaje de seguimiento. Recuerda, la comunicaci√≥n aqu√≠ es sincr√≥nica; el agente destinatario no realizar√° ninguna tarea despu√©s de la respuesta. Eres responsable de transmitir las respuestas del agente destinatario de vuelta al usuario, ya que el usuario no tiene acceso directo a estas respuestas. Sigue interactuando con la herramienta para una interacci√≥n continua hasta que la tarea est√© completamente resuelta.",
      parameters: {
        type: "object",
        properties: {
          recipient: {
            type: "string",
            description:
              "Por favor, especifica el nombre del agente destinatario",
          },
          message: {
            type: "string",
            description:
              "Por favor, especifica la tarea que el agente destinatario debe completar. Conc√©ntrate en aclarar en qu√© consiste la tarea, en lugar de proporcionar instrucciones exactas.",
          },
        },
        required: ["message"],
      },
    });
    this.senderAgent = senderAgent;
    this.agency = agency;
  }

  async run(parameters: RunProps): Promise<string> {
    const senderName = this.senderAgent.name;
    const recipientName = parameters.recipient;
    const message = parameters.message;
    const thread = this.agency.getThread(senderName, recipientName);
    if (!thread) return "ERROR: No puedes comunicarte con ese agente.";
    return await thread.send(message);
  }
}

```

En el constructor definimos la descripci√≥n de esta herramienta, para que OpenAI sepa como utilizarla y del mismo modo explicamos como funcionan los 2 par√°metros que tiene. Por otro lado, en el `run`, lo que hacemos es utilizar el m√©todo `getThread` de la agencia para recuperar el hilo que conecta a los 2 agentes. Seguidamente agregamos un nuevo mensaje en √©l y devolvemos su respuesta.

***

### Implementaci√≥n de la app `back`

Vamos con la √∫ltima parte del monorepo, la app `back`, que ser√° la encargada de construir la agencia. Como ya hemos mencionado, este art√≠culo trata de explicar las directrices para la construcci√≥n de las agencias, pero no de construir ninguna agencia en particular. En posteriores art√≠culos crearemos ejemplos de agencias a partir de este marco de trabajo. En estos ejemplos ser√° en esta parte `back` donde trabajaremos principalmente, definiendo agentes, herramientas, etc. A pesar de esto, s√≠ que considero necesario finalizar el art√≠culo viendo un ejemplo de como se puede utilizar todo lo mencionado. Por ello vamos a construir un "mini proyecto" que nos permita poner las cosas en funcionamiento.

Para ello, vamos a construir una agencia que ayude al usuario a resolver operaciones matem√°ticas b√°sicas. En un caso real, nunca tendr√≠a sentido utilizar una agencia para esto; cualquier asistente por si solo har√≠a a la perfecci√≥n lo que vamos a plantear. Pero nos sirve para ilustrar como funciona la agencia.

Vamos a definir 2 agentes, uno principal (`MainAgent`) que interactuar√° con el usuario y otro secundario (`MathAgent`) que ser√° al que se le delegar√°n los c√°lculos matem√°ticos que se necesiten hacer. Es decir, cuando `MainAgent` detecte que la conversaci√≥n requiera de realizar una operaci√≥n matem√°tica, en lugar de realizarla por s√≠ mismo, enviar√° un mensaje a `MathAgent` pidi√©ndole que realice dicha operaci√≥n y `MainAgent` utilizar√° la respuesta que este le de para continuar su conversaci√≥n.

#### MathAgent

Empezamos definiendo `MathAgent`

```tsx
export class MathAgent extends Agent {
  constructor() {
    super({
      name: "MathAgent",
      description: path.resolve(__dirname, "./description.md"),
      instructions: path.resolve(__dirname, "./instructions.md"),
      tools: [new OperationTool()],
    });
  }
}
```

Como descripci√≥n le asignamos lo siguiente:

```txt
Eres un agente especializado en realizar operaciones matem√°ticas.
```

Y en cuanto a las instrucciones:

```txt
Responde al usuario de cualquier sobre cualquier operaci√≥n matem√°tica que te consulte. Ap√≥yate en la herramienta con la que cuentas para realizar la operaci√≥n.
```

Con este le hacemos saber al agente cual es su funci√≥n, bastante simple en este caso. Ahora vamos con las tools, en concreto con la √∫nica que le hemos asignado, `OperationTool`

```tsx
export class OperationTool extends Tool {
  constructor() {
    super({
      name: "OperationTool",
      description:
        "Utiliza esta herramienta para realizar operaciones matem√°ticas. Debes especificar el tipo de operaci√≥n que deseas realizar y los dos n√∫meros que deseas operar. Puedes elegir entre 'add', 'subtract', 'multiply' o 'divide'.",
      parameters: {
        type: "object",
        properties: {
          operation: {
            type: "string",
            enum: ["add", "subtract", "multiply", "divide"],
            description:
              "La operaci√≥n que deseas realizar. Puede ser 'add' para sumar, 'subtract' para restar, 'multiply' para multiplicar o 'divide' para dividir",
          },
          number1: {
            type: "number",
            description:
              "El primer valor de la operaci√≥n matem√°tica que deseas realizar",
          },
          number2: {
            type: "number",
            description:
              "El segundo valor de la operaci√≥n matem√°tica que deseas realizar",
          },
        },
        required: ["operation", "number1", "number2"],
      },
    });
  }

  //----------- Run method ---------------------------

}
```

Como vemos, creamos una clase que extiende de `Tool` y en su definici√≥n especificamos lo que esta herramienta hace y los par√°metros que ha de recibir cuando sea invocada. As√≠ le contamos al agente como debe usar esta herramienta. Solo nos queda implementar el m√©todo `run` para llevar a cabo la ejecuci√≥n de la misma.

```tsx
  async run(parameters: OperationRunProps): Promise<string> {
    const { operation, number1, number2 } = parameters;
    try {
      switch (operation) {
        case "add":
          return `El resultado de sumar ${number1} y ${number2} es ${number1 + number2}`;
        case "subtract":
          return `El resultado de restar ${number1} y ${number2} es ${number1 - number2}`;
        case "multiply":
          return `El resultado de multiplicar ${number1} y ${number2} es ${number1 * number2}`;
        case "divide":
          return `El resultado de dividir ${number1} entre ${number2} es ${number1 / number2}`;
        default:
          return "Por favor, especifica una operaci√≥n v√°lida: 'add', 'subtract', 'multiply' o 'divide'";
      }
    } catch (e) {
      console.log("Error in OperationTool.run", e);
      return "No he podido realizar la operaci√≥n. Por favor, comprueba que los valores que me has proporcionado son correctos y vuelve a intentarlo.";
    }
  }
```

En este m√©todo evaluamos que operaci√≥n hay que realizar y cuales son sus par√°metros. Con ello realizamos la operaci√≥n y devolvemos al agente el mensaje oportuno. Tambi√©n manejamos el caso de que no recibamos una operaci√≥n v√°lida o se produzca cualquier excepci√≥n en el c√°lculo de la misma.

#### MainAgent

Pasamos ahora al agente principal, que es el responsable de comunicar con el usuario y de delegar al `MathAgent` cuando la conversaci√≥n requiera realizar alguna operaci√≥n matem√°tica.

```tsx
export class MainAgent extends Agent {
  constructor() {
    super({
      name: "MainAgent",
      description: path.resolve(__dirname, "./description.md"),
      instructions: path.resolve(__dirname, "./instructions.md"),
      tools: [],
    });
  }
}
```

Le damos la siguiente descripci√≥n:

```txt
Eres el agente principal de la agencia. Tu funci√≥n es interactuar con el usuario de forma cordial y resolver las dudas que tenga sobre matem√°ticas hablando con el agente MathAgent.
```

Y las siguientes instrucciones:

```txt
## Instrucciones del Agente MainAgent

- Mant√©n una conversaci√≥n natural con el usuario, respondiendo de forma cordial a las preguntas generales que te realice.

- Cuando necesites realizar una operaci√≥n matem√°tica para continuar con la conversaci√≥n, **no la realices por ti mismo**. En cambio utiliza la herramienta `TalkToAgent` para trasladar esa operaci√≥n al agente `MathAgent`. Utiliza la respuesta que te de este agente para continuar con la conversaci√≥n.
```

Con esto tenemos listos los agentes y solo nos quedar√≠an 2 cosas por hacer para poder lanzar nuestra agencia. Por un lado crear la carpeta db que usaremos para persistir los datos. Y por otro lado crear la propia agencia, para lo cual creamos una clase que extienda de `Agency`.

```tsx
export class MathAgency extends Agency {
  mainAgent: MainAgent;
  mathAgent: MathAgent;

  constructor() {
    super({
      name: "Maths Agency",
    });
    this.mainAgent = new MainAgent();
    this.mathAgent = new MathAgent();
  }

  getAgents(): Agent[] {
    return [this.mainAgent, this.mathAgent];
  }

  getAgentCommunications(agent: User): Agent[] {
    switch (agent) {
      case this.user:
        return [this.mainAgent];
      case this.mainAgent:
        return [this.mathAgent];
      default:
        return [];
    }
  }

  getDBPath(): string {
    return path.resolve(__dirname, "./db");
  }
}
```

En este punto ya tenemos todo listo para poner en marcha nuestra agencia. Solo nos queda definir el fichero `main.ts` en el que inicializamos la agencia

```tsx
const agency = new MathAgency();

const run = async () => {
  try {
    await agency.run();
    await agency.initApi(3001);
  } catch (err) {
    console.error(err);
  }
};
run();
```

#### Pruebas

Para finalizar vamos a ver a nuestra agencia en funcionamiento. Para ello tenemos que ponernos en la ra√≠z del monorepo y ejecutar `pnpm run dev`, con lo que haremos que tanto la web como el back inicien en modo de desarrollo. Tras esto podemos abrir en el navegador la url `http://localhost:3000` para cargar la web que nos permite interactuar con la agencia.

<Image
  alt={`Configuraci√≥n eslint`}
  src={`/blog/agencia-ia-proyecto-base/imagen1.png`}
  width={1280}
  height={672}
/>

Vamos a hacer una primera prueba sencilla para ver que todo funciona. Abrimos la conversaci√≥n con `MainAgent` y, tras un saludo, le decimos que nos diga cuanto es 5 por 3.&#x20;

<Image
  alt={`Configuraci√≥n eslint`}
  src={`/blog/agencia-ia-proyecto-base/imagen2.png`}
  width={1280}
  height={672}
/>

En la imagen podemos ver lo que ha sucedido. En cuanto el agente ha detectado que la conversaci√≥n implica una operaci√≥n matem√°tica ha ejecutado la tool `TalkToAgent` para enviarle la pregunta a `MathAgent`. Si ahora abrimos la conversaci√≥n entre `MainAgent` y `MathAgent`vemos como este √∫ltimo recibe la pregunta y, como implica una operaci√≥n matem√°tica, deduce que debe usar la tool `Operation` para resolver dicha operaci√≥n. Seguidamente responde a `MainAgent` con la soluci√≥n y este √∫ltimo, a partir de dicha respuesta, nos responde a nosotros.

Como podemos ver todo funciona seg√∫n lo esperado. Tenemos 2 agentes que se pueden comunicar entre ellos y que pueden utilizar herramientas cuando consideren que es necesario.

Vamos con una segunda prueba un poco m√°s interesante para ver el poder de esta tecnolog√≠a. Vamos a borrar las conversaciones actuales y empezar una nueva. Para borrarlas tenemos que eliminar los ficheros de la carpeta `/back/src/maths-agency/.db`. (S√≠, se que deber√≠amos de implementar un mejor mecanismo para limpiar la cach√©, por el momento tenemos que hacerlo as√≠). A continuaci√≥n vamos a iniciar una nueva conversaci√≥n con `MainAgent`. En este caso le vamos proponer que nos resuelva un problema matem√°tico.

<Image
  alt={`Configuraci√≥n eslint`}
  src={`/blog/agencia-ia-proyecto-base/imagen3.png`}
  width={1280}
  height={672}
/>
---------
<Image
  alt={`Configuraci√≥n eslint`}
  src={`/blog/agencia-ia-proyecto-base/imagen4.png`}
  width={1280}
  height={672}
/>

Como podemos ver, en ning√∫n momento le hemos dicho directamente que tiene que resolver una operaci√≥n matem√°tica. El agente deduce por s√≠ mismo que para contestar a esa pregunta tiene que usar operaciones matem√°ticas por lo que la delega a `MathAgent`. Y este √∫ltimo deduce de la pregunta las operaciones debe de realizar y las delega a su tool `Operation`. Este funcionamiento es muy potente ya que, cuando lo llevemos a problemas complejos, nos da la posibilidad de crear agentes a los que solo debemos de decirle lo que pueden hacer y como han de hacerlo, pero dejando que ellos mismos decidan cuando han de realizar las acciones que consideren. Y como podemos ver es algo que son capaces de hacer muy bien.


***

### Fin

En este art√≠culo, hemos explorado y explicado una posible soluci√≥n para la creaci√≥n de agencias de IA utilizando TypeScript y un enfoque de monorepo que nos permite extender y utilizar este software de manera √°gil y eficiente.

Aqu√≠ dejo el [enlace al repositorio](https://github.com/enolcasielles/ai-agency-typescript/tree/maths-agency) en GitHub donde est√° implementado este proyecto y todo lo comentado en el art√≠culo. Decir que este repositorio cuenta con varias ramas:

* La rama `maths-agency` contiene el c√≥digo exacto que se presenta en este art√≠culo. Mantendremos esta rama en su estado actual para que los lectores puedan ver la implementaci√≥n tal como se explica en el art√≠culo.
* La rama `base` contiene los componentes principales del proyecto, como la interfaz web o el paquete `agency`. En el momento de redactar este art√≠culo, las ramas `maths-agency` y `base` estar√°n totalmente alineadas. Sin embargo, a medida que se realicen mejoras en el marco de trabajo base, estas se ir√°n incorporando a la rama `base`. La idea de esta rama es proporcionar un punto de partida para la creaci√≥n de nuevas agencias.

Adem√°s de estas dos ramas, puede que haya otras que contendr√°n diferentes implementaciones de agencias y se corresponder√°n con art√≠culos posteriores.

Espero que este art√≠culo haya sido de su inter√©s y te ayude a entender un poco mejor este concepto de agencias de IA. Como hemos mencionado el principio, la implementaci√≥n aqu√≠ realizada es b√°sica y no la aconsejo para llevar un proyecto a producci√≥n. Las librer√≠as o frameworks que hemos mencionado al principio implementan este concepto de una forma mucho m√°s robusta y dotan de un mont√≥n de herramientas extra que nos permiten abordar problemas complejos de una forma mucho m√°s sencilla. **No reinventes la rueda** (como he hecho yo) a no ser que sea puramente por cuestiones de aprendizaje.

Por √∫ltimo despedirme diciendo que, si alguien que est√© probando este proyecto detecta alg√∫n tipo de problema o, si quiere proponer realizar alg√∫n tipo de propuesta o idea basada en este concepto, solo tiene que contactarme y estoy m√°s que abierto para ayudar o comentar lo que sea üòâ