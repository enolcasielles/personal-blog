---
title: 'Monorepo con pnpm'
publishedAt: '2024-01-22'
summary: 'En este art칤culo vamos a explicar las ventajas de utiliar un enfoque monorepo y ver un ejemplo de como construir uno'
---

# Construyendo un Monorepo en Typescript utilizando pnpm

En este art칤culo vamos a explicar lo que es un Monorepo, porqu칠 es interesante utilizarlos para ciertos tipos de proyectos y c칩mo podemos construir uno utilizando pnpm.

### 쯈u칠 es un monorepo?

Un monorepo, como su nombre indica, es un repositorio que contiene m칰ltiples paquetes o partes de un sistema. Pensemos por ejemplo en una arquitectura b치sica de un proyecto web. Podr칤amos tener por un lado un proyecto de front y por otro lado un proyecto de back. Ambos ser칤an totalmente independientes entre s칤, contando con su propio repositorio, c칩digo fuente, dependencias, etc.&#x20;

Por el contrario cuando trabajamos con un monorepo estos 2 proyectos estar칤an bajo el mismo repositorio, seguir칤an siendo totalmente independientes pero tendr칤amos la capacidad de, en los escenarios que queramos, compartir ciertas cosas entre ellos.

### 쮺uando es interesante utilizarlos?

Para ilustrar bien esto, vamos a imaginar que el ejemplo del apartado anterior tenemos que extenderlo y crear un tercer proyecto. Este proyecto ser치 otra frontal que utilizar치 otro tipo de usuario, por ejemplo un panel de administraci칩n. No ser칤a de extra침ar que este nuevo front comparta componentes de UI con el otro front, 쯨erdad?&#x20;

쮺omo solucionamos esto cuando trabajamos en una arquitectura multirepo? Pues probablemente copiando estos componentes al nuevo proyecto, lo cual nos fuerza a que, a partir de este momento, tengamos que mantener en 2 sitios componentes que son totalmente iguales.&#x20;

Tendr칤a mucho m치s sentido que esos componentes puedan estar en alg칰n sitio que ambos proyectos puedan utilizar, sin necesidad de tenerlos duplicados. Algo como por ejemplo un paquete externo que los 2 proyectos importen. Pues bien, este es el tipo de cosas que un enfoque monorepo nos permite hacer de forma sencilla y organizada.

Cuando estos 2 proyectos viven bajo el mismo monorepo, podemos a침adir un tercer proyecto que se encargue de implementar estos componentes comunes y que sea importado por ambos frontales.

### 쯄e das otro ejemplo?

Otro ejemplo interesante es cuando quieres compartir clases o modelos entre front y back. Frecuentemente ocurre que en el back defines unas clases con los modelos de respuesta que las diferentes llamadas devolver치n y, a su vez, en el front defines otras clases para gestionar la respuesta.&#x20;

Estas clases seguramente sean duplicadas en amos proyectos por lo que tendr칤a mucho m치s sentido si se encuentran en un paquete independiente y que ambos proyectos puedan importar. De nuevo un caso que una arquitectura monorepo nos permite implementar y mantener de forma sencilla.

### 쮺칩mo puedo construir un monorepo?

Vista un poco la teor칤a y la justificaci칩n de porqu칠 es interesante este enfoque vamos a ver c칩mo podemos construir uno en Typescript utilizando la herramienta pnpm, que es una alternativa a npm que por su dise침o y funcionamiento encaja mucho mejor para la construcci칩n de este tipo de arquitecturas.

Para empezar vamos a crear un nuevo proyecto vac칤o utilizando pnpm

```txt
pnpm init
```

> Has de tener pnpm instalado en tu m치quina. En su [web oficial](https://pnpm.io/installation) puedes ver como instalarlo

Esto nos crear치 en la carpeta el t칤pico `package.json`. Hasta este punto lo que tenemos es un proyecto de node est치ndar gestionado por pnpm. Para convertirlo a un proyecto monorepo lo que tenemos que hacer es crear un fichero `pnpm-workspace.yaml` con el siguiente contenido:

```txt
packages:
  - "apps/*"
  - "packages/*"
```

Este fichero lo que hace es especificar en que rutas estar치n los distintos paquetes de nuestro monorepo. En esta caso definimos 2 posibles carpetas,  `apps` y `packages` por lo que podemos aprovechar ya para crear estas 2 carpetas en nuestro proyecto, que de momento las dejamos vac칤as. &#x20;

Hacemos esta distinci칩n de carpetas para diferenciar las aplicaciones de lo que son los paquetes que van a ser utilizados por estas aplicaciones. Esto no es obligatorio, para el monorepo no hay distinci칩n alguna entre lo que es una app y lo que es un paquete, la hacemos nosotros por la diferencia conceptual de lo que representan. A partir de ahora cuando hablemos de un paquete ser치 aplicable a cualquiera de los 2 tipos, ya que realmente, es as칤 en la terminolog칤a utilizada en un monorepo con pnpm.

Como ya hemos comentado cada uno de los paquetes ser치n entidades independientes, nuevos proyectos pnpm que contar치n con su package.json, con su listado de dependencias, scripts personalizados, etc, etc. Pero lo que es importante destacar es que al estar en el monorepo ser치 este quien se encargue de gestionar las dependencias de cada uno de ellos. Esto quiere decir que, cuando instalamos una dependencia en alguno de los paquetes ser치 el monorepo quien la instalar치 y quien decidir치 que el alcance de dicha dependencia es para dicho paquete y no para el resto. Ahora bien, 쯤u칠 pasa si instalamos una dependencia en el paquete ra칤z? Recordemos que el paquete ra칤z no deja de ser un proyecto pnpm tambi칠n, por lo que perfectamente se puede instalar algo a este nivel. Pues bien, lo que pasar치 es que dicha dependencia estar치 disponible en todos los paquetes.

Por lo general no querremos instalar dependencias en ra칤z pero s칤 que es habitual hacer alguna excepci칩n. Por ejemplo, algo que yo suelo hacer es instalar el typescript y configurar el eslint a este nivel de ra칤z. La raz칩n de hacer esto es que tengo 100% claro que todos los paquetes se van a escribir en Typescript y quiero unificar las reglas de escritura de c칩digo en todos ellos. Pero esto de nuevo no tiene porqu칠 ser as칤, es una decisi칩n totalmente de cultura de ingenier칤a del proyecto.

### Instalando dependencias globales

Dicho lo anterior vamos a configurar estas dependencias visibles para todos los paquetes. Para ello simplemente nos tenemos que ubicar en la ra칤z del proyecto y ejecutar:

```txt
pnpm install typescript eslint -w
```

Importante destacar el uso de la flag -w. Cuando tratas de instalar algo en la ra칤z del monorepo, por defecto pnpm te lanza un warning para que tengas en cuenta que est치s en ra칤z. Como no es lo habitual instalar dependencias a este nivel considera que puede ser un error y te advierte. Con la flag -w indicas que eres consciente de ello y que quieres instalarlo en ra칤z, evitando que te salte el aviso. Este comportamiento tambi칠n puede ser evitado estableciendo un ajuste en el proyecto, lo veremos m치s adelante.

Una vez hemos hecho esto ya podemos ver como estas 2 dependencias han sido instaladas y aparecen en en el package.json de ra칤z. Vamos a proceder ahora a configurar eslint, para ello vamos a utilizar el configurador que la propia dependencia nos ofrece. Pero antes de hacer esto es importante que tengamos en cuenta algo. Como dec칤amos antes pnpm bloquea las instalaciones a nivel ra칤z si no llevan la flag -w. El configurador de eslint, a pesar de que s칤 est치 preparado para realizar la instalaci칩n usando pnpm, no la har치 utilizando esta flag -w, por lo que no podr치 finalizar correctamente. 쮺칩mo podemos solucionar esto? Estableciendo un ajuste que le indique a pnpm que ignore este warning. Esto se hace creando un fichero .npmrc e insertando la siguiente l칤nea:

```txt
ignore-workspace-root-check=true
```

Con esto el warning ser치 ignorado y se podr치 instalar en ra칤z sin la flag -w. Procedemos entonces a la configuraci칩n del eslint:

```txt
pnpm eslint --init
```

![](/sample-image.png)

El resultado de este configurador ser치 la instalaci칩n de las dependencias necesarias y la creaci칩n del fichero .eslintrc.json en la ra칤z del proyecto:

```txt
{
    "env": {
        "browser": true,
        "es2021": true,
        "node": true
    },
    "extends": "standard-with-typescript",
    "parserOptions": {
        "ecmaVersion": "latest",
        "sourceType": "module"
    },
    "rules": {
    }
}

```

En este punto tenemos todo listo para empezar a crear paquetes en el monorepo 游

### Definiendo el proyecto

Antes de empezar con la implementaci칩n de los diferentes paquetes, vamos a explicar brevemente el proyecto que a modo de ejemplo vamos a abordar. Ser치 algo muy sencillo ya que lo que queremos es focalizar en como funciona el monorepo y no en la aplicaci칩n en s칤 mismo. Por esa raz칩n no voy a entrar en detalle en nada referente a la implemtaci칩n de la aplicaci칩n. Solo mencionar que ser치 la t칤pica App lista de tareas, con un front hecho con React + Vite y una Api hecha con Express, ambos proyectos en Typescript y con una implementaci칩n muy sencilla.&#x20;

Adem치s, para ilustrar mejor como usar un monorepo, crearemos un paquete llamado core que ser치 consumido por ambas apps y que definir치 clases o tipos que ambos puedan necesitar.

En el enlace al repo que dejo al final del art칤culo pod칠is ver la implementaci칩n completa de cada parte.

### Creando el primer paquete

Vamos a empezar con la creaci칩n de la app para el front. Nos vamos a la carpeta app y creamos un proyecto React usando Vite:

```txt
pnpm create vite@latest front -- --template react-ts
```

Seguimos las instrucciones del configurador para crear el proyecto React con Typescript e instalar todos los paquetes necesarios. Si tras instalarlo nos vamos a apps/front y hacemos pnpm run dev deber칤amos poder lanzar correctamente el proyecto React en ejecuci칩n. Vamos a hacer ahora algunas modificaciones para adaptarlo mejor al monorepo.

Antes que nada, vamos a decirle a vite que utilice el puerto 3000 para nuestro front, en lugar de una aleatorio como hace por defecto. Nos vamos al vite.config.ts y agregamos el siguiente objeto server:

```txt
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
  }
})
```

A continuaci칩n vamos a adaptar el proyecto un poco mejor para vivir en el monorepo. La instalaci칩n por defecto de Vite configurar치 su propio typescript y eslint, pero como hemos comentado, nosotros queremos usar el del monorepo. Por tanto lo que haremos es desinstalar localmente estas dependencias y eliminar todos los ficheros. Nos vamos al package.json y eliminamos las siguientes dependecias:

```txt
typescript
eslint
@typescript-eslint/eslint-plugin
@typescript-eslint/parser
```

> En el momento de escribir este art칤culo estas eran las dependencias relacionadas con typescript o eslint que vite instalaba por defecto. Puede que en tu caso esto cambie un poco seg칰n la versi칩n de Vite utilizada, aseg칰rate de eliminar todas aquellas que tengan que ver con estas herramientas.

Una vez eliminadas en el package.json ejecutamos pnpm install en apps/front para que la desinstalaci칩n se lleve a cabo. Por 칰ltimo eliminamos el fichero .eslintrc para que no utilice la configuraci칩n de eslint que ah칤 se indica. Tras hacer esto nuestro proyecto front ya deber칤a coger las reglas de eslint definidas en ra칤z, sigui칠ndolas al 100%.&#x20;

S칤 que es cierto que, seg칰n el tipo de proyecto Typescript en el que estemos, quiz치 nos interese tener alguna configuraci칩n diferente. Por ejemplo, este paquete front es una aplicaci칩n con React y en este caso es muy com칰n instalar un plugin de eslint para React (eslint-plugin-react) pero no tiene sentido que instalemos este plugin en ra칤z y que nuestro proyecto api tambi칠n estar칤a expuesto a lo que dicte este plugin. Por tanto aqu칤 vamos a ver otro tema interesante que es como se puede adaptar la configuraci칩n de eslint para cada proyecto.&#x20;

Primero instalamos a este nivel front el paquete con el plugin mencionado

```txt
pnpm install -D eslint-plugin-react
```

Luego creamos otro fichero .eslintrc.json a nivel front y agregamos en 칠l lo siguiente:

```txt
{
  "extends": [
    "../../.eslintrc", 
    "plugin:react/recommended"
  ],
  "plugins": [
      "react"
  ],
  "rules": {}
}
```

Con esto lo que estamos indicando es, primero que extienda de la configuraci칩n que tenemos definida en ra칤z. Luego que extienda tambi칠n de lo que nos define el plugin de React. Tambi칠n que utilice dicho plugin para que pueda realiza dicha extensi칩n. Por 칰ltimo, al igual que hemos hecho en ra칤z definimos unas reglas personalizadas que por el momento estar치n vac칤as.

&#x20;Si utilizas VSCode y la extensi칩n para eslint, en este momento te deber칤an aparecer errores en tus archivos. Por ejemplo, podemos abrir el App.tsx y ver como hay varios errores de sintaxis. Esto es debido a que ahora la configuraci칩n de eslint es la que viene de Standard, la gu칤a de estilos que decidimos elegir cuando configuramos eslint en ra칤z, extendida adem치s por la del plugin de React que le acabamos de a침adir. Entonces tenemos que adaptar nuestro c칩digo para cumplir con esto. Tenemos 2 opciones para abordarlo: arreglar los errores que nos indica o modificar las reglas definidas. Esto de nuevo ya es una decisi칩n que has de tomar seg칰n como quieras afrontar tu desarrollo.

En mi caso lo que har칠 ser치 una mezcla de ambas opciones. A침adir칠 las siguientes 3 reglas a la configuraci칩n de eslint en ra칤z:

```txt
{
  //...
  "rules": {
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/no-floating-promises": "off",
    "@typescript-eslint/no-misused-promises": "off"
  }
}
```

Y a침adir칠 la siguiente a la configuraci칩n del proyecto front:

```txt
{
  //...
  "rules": {
    "react/react-in-jsx-scope": "off"
  }
}
```

Y una vez hecho esto corregir칠 el resto de errores o warnings que eslint me indique.

En este punto ya tenemos todo listo para crear nuestra App. Como dec칤a anteriormente no vamos  a entrar en detalles de la implementaci칩n, puedes ir al repo y ver como est치 hecho.

### Creando otro paquete para la Api

Ahora que ya hemos visto como crear y adaptar un proyecto al monorepo vamos a hacer lo mismo para la Api. Como hab칤amos dicho implementaremos una Api usando Express.

Nos vamos a la carpeta apps y creamos un nuevo directorio llamada api. En este caso no usaremos ning칰n generador. Entramos en la carpeta api y creamos un nuevo proyecto pnpm vac칤o.

```txt
mkdir api && cd api && pnpm init
```

Instalamos las dependencias necesarias

```txt
pnpm add express
pnpm add -D @types/express @types/node nodemon ts-node
```

B치sicamente lo que estamos haciendo es instalar express y como dependencias de desarrollo:

* Los tipos de express y node
* nodemon, que es una herramienta que nos permite f치cilmente hacer que el servidor se recargue con los cambios en los ficheros&#x20;
* ts-node, que b치sicamente digamos que nos permite ejecutar directamente el typescript

Agregamos un fichero nodemon.json en ra칤z para definir como ha de funcionar esta herramienta

```txt
{
  "watch": ["src"],
  "ext": "ts",
  "exec": "ts-node ./src/index.ts"
}
```

Lo que aqu칤 le estamos diciendo es que ha de escuchar a los ficheros en la carpeta src con extensi칩n .ts y que cada vez que se guarde uno de ellos ejecute ts-node en el fichero principal. Con eso lo que conseguimos es ejecutar directamente la api con typescript (ts-node se encarga por debajo de todo) y hacer que se recargue con cada cambio (nodemon se encarga)

Agregamos tambi칠n el fichero tsconfig para indicar como se ha de realizar el transpilado a javascript, as칤 como algunas reglas de linting.

```txt
{
  "compilerOptions": {

    "module": "commonjs",
    "target": "ES2020",
    "outDir": "./dist",
    "incremental": true,
    "allowSyntheticDefaultImports": true,
    
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

  }
}


```

Por 칰ltimo creamos los scripts en el package.json para realizar el dev, el build y el start.

```txt
{
  // ---
  "scripts": {
    //---
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "nodemon"
  },
}
```



### Creando un paquete compartido

Lo siguiente que vamos a hacer es crear el paquete core, en el que implementaremos aquellas cosas que puedan ser comunes en ambas aplicaciones front y api. Creamos una nueva carpeta en packages llamada core y estando en ella creamos de nuevo un proyecto pnpm b치sico.&#x20;

```txt
pnpm init
```

A continuaci칩n creamos el tsconfig para especificar a typescript como ha de realizar el compilado a javascript. Vamos a usar la misma configuraci칩n que en el proyecto api:

```txt
{
  "compilerOptions": {

    "module": "ESNext",
    "target": "ES2015",
    "outDir": "./dist",
    "incremental": true,
    "allowSyntheticDefaultImports": true,
    "isolatedModules": true,
    
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": true,
    
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

  }
}


```

A diferencia del tsconfig que creamos para la Api, que contaba

Agregamos los scripts para hacer el build y el dev en el package.json

```txt
{
  // ---
  "scripts": {
    //---
    "build": "tsc",
    "dev": "tsc -w"
  },
}

```

El dev en este caso es mucho m치s sencillo si lo comparamos con el proyecto api. Aqu칤 no tenemos ning칰n servidor en ejecuci칩n ni nada por el estilo. Lo 칰nico que necesitamos es recompilar cuando se guarde cambios.

Y con esto ya tenemos tambi칠n listo este paquete para escribir el c칩digo que necesitemos. Al igual que los anteriores en el repo se puede ver la implementaci칩n completa, que no ser치 nada m치s que una clase Task.

### Scripts en paralelo

Para ir finalizando este art칤culo vamos a ver una cosa interesante de los monorepos que a칰n no hemos comentado, la posibilidad de ejecutar todos los scripts a la vez y en paralelo. Si nos fijamos, los 3 paquetes tienen un script dev. Es muy posible cuando estemos desarrollando que queramos tener levantados estos entornos de desarrollo en los 3 paquetes. Pues pnpm nos permite hacer esto de una forma muy sencilla. Simplemente tenemos que ir al package.json de ra칤z y definir ah칤 el siguiente script dev

```txt
{
  // ---
  "scripts": {
    //---
    "dev": "pnpm run --parallel dev",
  },
}
```

Esto lo que hace es buscar todos los scripts dev que haya en cada uno de los paquetes que conforman el monorepo y ejecutarlos en paralelo.

Otra cosa interesante que nos ofrece pnpm  es la de poder filtrar un script a solo ciertos paquetes. Esto se consigue utilizando el flag --filter. Esto nos da juego a que creemos scripts con las operaciones habituales de desarrollo que m치s necesitemos. Por ejemplo podr칤amos configurar para desde ra칤z poder levantar cada una de las apps por separado o las 2 a la vez pero sin el paquete core

```txt
{ 
  // ---
  "scripts": {
    //---
    "dev": "pnpm run --parallel dev",
    "dev:front": "pnpm run --filter front dev",
    "dev:api": "pnpm run --filter api dev",
    "dev:apps": "pnpm run --filter api --filter front dev"
  },
}
    
```

### Link al repo y fin

Y hasta aqu칤 hemos llegado. Espero que este art칤culo sirva como una introducci칩n para empezar a trabajar con monorepos en typescript usando pnpm y, como ya he dicho varias veces a lo largo del mismo, dejo por aqu칤 en enlace al repo en github donde puedes ver implementado este peque침o ejemplo del uso de un monorepo

LINK