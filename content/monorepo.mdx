---
title: Monorepo con pnpm
publishedAt: '2024-01-22'
summary: >-
  En este art√≠culo vamos a explicar las ventajas de utiliar un enfoque monorepo
  y ver un ejemplo de como construir uno
---

## Construyendo un Monorepo en Typescript utilizando pnpm

En este art√≠culo, explicaremos qu√© es un Monorepo, por qu√© es beneficioso utilizarlo en ciertos tipos de proyectos y c√≥mo podemos construir uno utilizando `pnpm`

### ¬øQu√© es un monorepo?

Un monorepo, como su nombre indica, es un **repositorio √∫nico** que contiene m√∫ltiples paquetes o partes de un sistema. Pensemos, por ejemplo, en una arquitectura b√°sica de un proyecto web. Podr√≠amos tener, por un lado, un proyecto de frontend y, por otro, un proyecto de backend. Ambos ser√≠an totalmente independientes entre s√≠, contando con su propio repositorio, c√≥digo fuente, dependencias, etc.

Por el contrario, cuando trabajamos con un monorepo, estos dos proyectos estar√≠an bajo el mismo repositorio. Seguir√≠an siendo totalmente independientes en t√©rminos de despliegue y ejecuci√≥n, pero tendr√≠amos la capacidad de compartir ciertos elementos entre ellos cuando sea necesario.

### ¬øCuando es interesante utilizarlos?

Para ilustrar esto mejor, imaginemos que en el ejemplo anterior tenemos que extenderlo y crear un tercer proyecto. Este proyecto ser√° otro frontend que utilizar√° otro tipo de usuario, por ejemplo, un panel de administraci√≥n. No ser√≠a de extra√±ar que este nuevo frontend comparta componentes de UI con el otro frontend, ¬øverdad?

¬øC√≥mo solucionamos esto cuando trabajamos en una arquitectura multirepo? Probablemente copiando estos componentes al nuevo proyecto, lo cual nos obliga a mantener componentes id√©nticos en dos lugares diferentes.

Tendr√≠a mucho m√°s sentido que esos componentes est√©n en alg√∫n sitio donde ambos proyectos puedan utilizarlos, sin necesidad de duplicarlos. Algo como un paquete externo que ambos proyectos importen. Pues bien, un enfoque monorepo nos habilita el hacer esto de una forma sencilla y organizada.

Cuando estos dos proyectos viven bajo el mismo monorepo, podemos a√±adir un tercer proyecto (o paquete) que se encargue de implementar estos componentes comunes y que sea importado por ambos frontends.

### Otro ejemplo

Otro ejemplo interesante es cuando queremos compartir clases o modelos entre el frontend y el backend. Frecuentemente, en el backend se definen clases con los modelos de respuesta que los diferentes endpoints devolver√°n y, a su vez, en el frontend defines tambi√©n modelos para gestionar la respuesta.

Estas clases probablemente sean duplicadas en ambos proyectos, por lo que tendr√≠a mucho m√°s sentido si se encuentran en un paquete independiente que ambos proyectos puedan importar. De nuevo, un caso que una arquitectura monorepo nos permite implementar y mantener de forma sencilla.

### ¬øC√≥mo puedo construir un monorepo?

Vista la teor√≠a y la justificaci√≥n de por qu√© es interesante este enfoque, vamos a ver c√≥mo podemos construir uno en TypeScript utilizando la herramienta `pnpm`, que es una alternativa a npm que, por su dise√±o y funcionamiento, encaja mucho mejor para la construcci√≥n de este tipo de arquitecturas.

Para empezar, nos ubicamos en la carpeta de trabajo y creamos un nuevo proyecto vac√≠o utilizando `pnpm`.

```txt
pnpm init
```

> Debes tener pnpm instalado en tu m√°quina. En su [web oficial](https://pnpm.io/installation) puedes ver como instalarlo

Esto nos crear√° el t√≠pico `package.json` en la carpeta. Hasta este punto, lo que tenemos es un proyecto de Node est√°ndar gestionado por `pnpm`. Para convertirlo a un proyecto monorepo, tenemos que crear un archivo `pnpm-workspace.yaml`

```txt
packages:
  - "apps/*"
  - "packages/*"
```

Este archivo especifica en qu√© rutas estar√°n los distintos paquetes de nuestro monorepo. En este caso, definimos dos posibles carpetas, `apps` y `packages`, por lo que podemos aprovechar ya para crear estas dos carpetas en nuestro proyecto, que de momento las dejamos vac√≠as.

> Hacemos esta distinci√≥n de carpetas para diferenciar las aplicaciones de los paquetes que van a ser utilizados por estas aplicaciones. Esto no es obligatorio; para el monorepo no hay distinci√≥n alguna entre lo que es una app y lo que es un paquete. La hacemos nosotros por la diferencia conceptual de lo que representan. A partir de ahora, cuando hablemos de un paquete, ser√° aplicable a cualquiera de los dos tipos, ya que realmente, es as√≠ en la terminolog√≠a utilizada en un monorepo con pnpm

Como ya hemos comentado, cada uno de los paquetes ser√° una entidad independiente, nuevos proyectos pnpm que contar√°n con su `package.json`, con su listado de dependencias, scripts personalizados, etc. Pero lo importante es que al estar en el monorepo, ser√° este quien se encargue de gestionar las dependencias de cada uno de ellos. Esto quiere decir que, cuando instalamos una dependencia en alguno de los paquetes, ser√° el monorepo quien la instalar√° y quien decidir√° que el alcance de dicha dependencia es para dicho paquete y no para el resto. Ahora bien, ¬øqu√© pasa si instalamos una dependencia en el paquete ra√≠z? Recordemos que el paquete ra√≠z no deja de ser un proyecto pnpm tambi√©n, por lo que se puede instalar algo a este nivel. Pues bien, lo que pasar√° es que dicha dependencia estar√° disponible en todos los paquetes.

Por lo general, no querremos instalar dependencias en ra√≠z, pero s√≠ es habitual hacer alguna excepci√≥n. Por ejemplo, algo que suelo hacer es instalar TypeScript y configurar eslint a este nivel de ra√≠z. La raz√≥n de hacer esto es que s√© seguro que todos los paquetes se van a escribir en TypeScript y quiero unificar las reglas de escritura de c√≥digo en todos ellos. Pero esto no tiene por qu√© ser as√≠; es una decisi√≥n totalmente de la cultura de ingenier√≠a del proyecto.

### Instalando dependencias globales

Dicho lo anterior, vamos a configurar estas dependencias visibles para todos los paquetes. Para ello, simplemente nos ubicamos en la ra√≠z del proyecto y ejecutamos:

```txt
pnpm install typescript eslint -w
```

Es importante destacar el uso de la flag -w. Cuando tratas de instalar algo en la ra√≠z del monorepo, por defecto `pnpm` te lanza una advertencia para que tengas en cuenta que est√°s en ra√≠z. Como no es lo habitual instalar dependencias a este nivel, `pnpm` considera que puede ser un error y te advierte. Con la flag -w indicas que eres consciente de ello y que quieres instalarlo en ra√≠z, evitando que te salte el aviso. Este comportamiento tambi√©n puede ser evitado estableciendo un ajuste en el proyecto, lo veremos m√°s adelante.

Una vez hecho esto, ya podemos instalar estas dos dependencias y ver como aparecen en el `package.json` de ra√≠z. Vamos a proceder ahora a configurar `eslint`, para ello vamos a utilizar el configurador que la propia dependencia nos ofrece. Pero antes de hacer esto es importante que tengamos en cuenta algo. Como dec√≠amos antes, `pnpm` bloquea las instalaciones a nivel ra√≠z si no llevan la flag -w. El configurador de `eslint`, a pesar de que s√≠ permite la instalaci√≥n usando `pnpm`, no utilizar√° esta flag -w, por lo que no podr√° finalizar correctamente. ¬øC√≥mo podemos solucionar esto? Estableciendo un ajuste a nivel proyecto que le indique a `pnpm` que ignore esta advertencia. Esto se hace creando un archivo `.npmrc` e insertando la siguiente l√≠nea:

```txt
ignore-workspace-root-check=true
```

Con esto, la advertencia ser√° ignorada y se podr√° instalar en ra√≠z sin la flag -w. Procedemos entonces a la configuraci√≥n del `eslint`:

```txt
pnpm eslint --init
```

<Image
  alt={`Configuraci√≥n eslint`}
  src={`/blog/monorepo/eslint.gif`}
  width={1280}
  height={720}
/>

El resultado de este configurador ser√° la instalaci√≥n de las dependencias necesarias y la creaci√≥n del fichero `.eslintrc.json` en la ra√≠z del proyecto:

```txt
{
    "env": {
        "browser": true,
        "es2021": true,
        "node": true
    },
    "extends": "standard-with-typescript",
    "parserOptions": {
        "ecmaVersion": "latest",
        "sourceType": "module"
    },
    "rules": {
    }
}

```

En este punto, tenemos todo listo para empezar a crear paquetes en el monorepo üöÄ

### Definiendo el proyecto

Antes de empezar con la implementaci√≥n de los diferentes paquetes, vamos a explicar brevemente el proyecto que, a modo de ejemplo, vamos a abordar. Ser√° algo muy sencillo ya que queremos centrarnos en c√≥mo funciona el monorepo y no en la aplicaci√≥n en s√≠ misma. Por esa raz√≥n, no voy a entrar en detalle en nada referente a la implementaci√≥n de la aplicaci√≥n. Solo mencionar que ser√° la t√≠pica App de lista de tareas, con un frontend hecho con `React + Vite` y una API hecha con `Express`, ambos proyectos en TypeScript.

Adem√°s, para ilustrar mejor como usar un monorepo, crearemos un paquete llamado `core` que ser√° consumido por ambas apps y que definir√° clases o tipos que ambos puedan necesitar.

> En el enlace al repo que dejo al final del art√≠culo, pod√©is ver la implementaci√≥n completa de cada parte

### Creando el primer paquete

Vamos a empezar con la creaci√≥n de la app para el frontend. Nos vamos a la carpeta `apps` y creamos un proyecto en React usando Vite:

```txt
pnpm create vite@latest front -- --template react-ts
```

Seguimos las instrucciones del configurador para crear el proyecto React con TypeScript e instalar todos los paquetes necesarios. Si tras instalarlo, nos vamos a `apps/front` y hacemos `pnpm run dev`, deber√≠amos poder lanzar correctamente el proyecto React en ejecuci√≥n. Vamos a hacer ahora algunas modificaciones para adaptarlo mejor al monorepo.

Antes que nada, vamos a decirle a Vite que utilice el puerto 3000 para nuestro frontend, en lugar de uno aleatorio como hace por defecto. Nos vamos al `vite.config.ts` y agregamos el siguiente objeto `server`:

```txt
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
  }
})
```

A continuaci√≥n, vamos a adaptar el proyecto un poco mejor para vivir en el monorepo. La instalaci√≥n por defecto de Vite configurar√° su propio TypeScript y eslint, pero como hemos comentado, nosotros queremos usar el del monorepo. Por tanto, lo que haremos es desinstalar localmente estas dependencias y eliminar todos los archivos. Nos vamos al `package.json` y eliminamos las siguientes dependencias:

```txt
typescript
eslint
@typescript-eslint/eslint-plugin
@typescript-eslint/parser
```

> En el momento de escribir este art√≠culo, estas eran las dependencias relacionadas con TypeScript o eslint que Vite instalaba por defecto. Puede que en tu caso esto cambie un poco seg√∫n la versi√≥n de Vite utilizada. Aseg√∫rate de eliminar todas aquellas que tengan que ver con estas herramientas.

Una vez eliminadas en el `package.json`, ejecutamos `pnpm install` en `apps/front` para que la desinstalaci√≥n se lleve a cabo. Por √∫ltimo, eliminamos el archivo `.eslintrc` para que no utilice la configuraci√≥n de `eslint` que ah√≠ se indica. Tras hacer esto, nuestro proyecto frontend ya deber√≠a usar las reglas de `eslint` definidas en ra√≠z.

Ahora bien, es cierto que, seg√∫n el tipo de proyecto TypeScript en el que estemos, quiz√° nos interese tener alguna configuraci√≥n diferente. Por ejemplo, este paquete frontend es una aplicaci√≥n con React y, en este caso, es muy com√∫n instalar el plugin de eslint para React `eslint-plugin-react`. No tiene sentido que instalemos este plugin en ra√≠z y que nuestro proyecto `api` tambi√©n est√© expuesto a lo que dicte este plugin. Por tanto, vamos a ver c√≥mo se puede adaptar la configuraci√≥n de `eslint` para cada proyecto.

Primero, instalamos a este nivel `front` el paquete con el plugin mencionado.

```txt
cd apps/front
pnpm install -D eslint-plugin-react
```

Luego creamos otro fichero `.eslintrc.json` a nivel `front` y agregamos lo siguiente:

```txt
{
  "extends": [
    "../../.eslintrc", 
    "plugin:react/recommended"
  ],
  "plugins": [
      "react"
  ],
  "rules": {}
}
```

As√≠ le estamos indicando lo siguiente: por un lado, que utilice dicho plugin para React; por otro lado, que extienda la configuraci√≥n que tenemos definida en ra√≠z; y por √∫ltimo, que extienda tambi√©n lo que nos define el propio plugin. Finalmente, al igual que hemos hecho en ra√≠z, definimos unas reglas personalizadas, por el momento vac√≠as.

Si utilizas VSCode y la extensi√≥n para `eslint`, en este momento deber√≠an aparecer errores en tus archivos. Por ejemplo, podemos abrir el `App.tsx` y ver c√≥mo hay varios errores de sintaxis. Esto se debe a que ahora la configuraci√≥n de `eslint` es la que viene de Standard, la gu√≠a de estilos que decidimos elegir cuando configuramos `eslint` en ra√≠z, extendida adem√°s por la del plugin de React que le acabamos de a√±adir. Entonces, tenemos que adaptar nuestro c√≥digo para cumplir con esto. Tenemos dos opciones para abordarlo: arreglar los errores que nos indica o modificar las reglas definidas. Esto, de nuevo, es una decisi√≥n que has de tomar seg√∫n c√≥mo quieras afrontar tu desarrollo.

En mi caso, lo que har√© ser√° una mezcla de ambas opciones. A√±adir√© las siguientes tres reglas a la configuraci√≥n de eslint en ra√≠z:

```txt
{
  //...
  "rules": {
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/no-floating-promises": "off",
    "@typescript-eslint/no-misused-promises": "off"
  }
}
```

Y a√±adir√© la siguiente a la configuraci√≥n del proyecto front:

```txt
{
  //...
  "rules": {
    "react/react-in-jsx-scope": "off"
  }
}
```

Una vez hecho esto, corregir√© el resto de errores o advertencias que eslint me indique.

En este punto, ya tenemos todo listo para crear nuestra App. Como dec√≠a anteriormente, no vamos a entrar en detalles de la implementaci√≥n. Puedes ir al repo y ver c√≥mo est√° hecho.

### Creando otro paquete para la Api

Ahora que ya hemos visto c√≥mo crear y adaptar un proyecto al monorepo, vamos a hacer lo mismo para la API. Como hab√≠amos dicho, implementaremos una API usando Express.

Nos vamos a la carpeta `apps` y creamos un nuevo directorio llamada `api`. En este caso no usaremos ning√∫n generador. Entramos en la carpeta `api` y creamos un nuevo proyecto pnpm vac√≠o.

```txt
cd apps
mkdir api && cd api && pnpm init
```

Instalamos las dependencias necesarias

```txt
pnpm add express
pnpm add -D @types/express @types/node nodemon ts-node
```

B√°sicamente, lo que estamos haciendo es instalar Express y como dependencias de desarrollo:

* Los tipos de Express y Node
* Nodemon, que es una herramienta que nos permite recargar el servidor al guardar cambios en los archivos
* ts-node, que nos permite ejecutar directamente c√≥digo Typescript

Agregamos un fichero `nodemon.json` en ra√≠z para especificar como debe funcionar esta herramienta.

```txt
{
  "watch": ["src"],
  "ext": "ts",
  "exec": "ts-node ./src/index.ts"
}
```

As√≠ le estamos indicando es que debe escuchar a los archivos en la carpeta `src` con extensi√≥n .ts para que, cada vez que se guarde uno de ellos, ejecute `ts-node` en el archivo principal. Con eso, conseguimos ejecutar directamente la API con Typescript (ts-node se encarga por debajo de todo) y hacer que se recargue con cada cambio (nodemon se encarga)

Agregamos tambi√©n el fichero `tsconfig.json` para indicar como se ha de realizar el transpilado a Javascript, as√≠ como algunas reglas de linting.

```txt
{
  "compilerOptions": {

    "module": "commonjs",
    "target": "ES2020",
    "outDir": "./dist",
    "incremental": true,
    "allowSyntheticDefaultImports": true,
    
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

  }
}


```

Por √∫ltimo creamos los scripts en el `package.json` para realizar el dev, el build y el start.

```txt
{
  // ---
  "scripts": {
    //---
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "nodemon"
  },
}
```

### Creando un paquete compartido

Lo siguiente que vamos a hacer es crear el paquete `core`, en el que implementaremos aquellas cosas que puedan ser comunes en ambas aplicaciones frontend y API. Creamos una nueva carpeta en `packages` llamada `core` y, estando en ella, creamos de nuevo un proyecto `pnpm` b√°sico.

```txt
cd packages
mkdir core
cd core
pnpm init
```

A continuaci√≥n creamos el `tsconfig.json` para especificar a Typescript como ha de realizar el compilado a Javascript.

```txt
{
  "compilerOptions": {

    "module": "ESNext",
    "target": "ES2015",
    "outDir": "./dist",
    "incremental": true,
    "allowSyntheticDefaultImports": true,
    "isolatedModules": true,
    
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": true,
    
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

  }
}

```

> Esta configuraci√≥n es similar a la del proyecto API. En este caso, como sistema de m√≥dulos, usamos ESNext que lo har√° m√°s compatible para ser importado por las diferentes apps. Adem√°s, agregamos algunas propiedades que permiten generar las declaraciones de tipos y los archivos de mapas entre el c√≥digo fuente y el c√≥digo compilado. Esto es interesante ya que ayuda al IDE a entender la estructura del paquete y facilita cosas como ir a la definici√≥n de aquello que el paquete exporte cuando lo estamos usando en otro paquete

Creamos tambi√©n un `nodemon.json` para poder realizar el compilado en modo desarrollo:

```txt
{
  "watch": ["src"],
  "ext": "ts",
  "exec": "npm run build"
}
```

Y finalmente, agregamos los scripts para hacer el build y el dev en el `package.json`

```txt
{
  // ---
  "scripts": {
    //---
    "build": "tsc -p tsconfig.json",
    "dev": "nodemon"
  },
}

```

Y con esto ya tenemos tambi√©n listo este paquete para escribir el c√≥digo que necesitemos.

### Importando el paquete

Lo √∫nico que tenemos que hacer ahora es importar el paquete `core` en las apps. Esto lo hacemos como cualquier otro paquete, nos vamos al directorio de cada una de las apps y hacemos:

```txt
pnpm add core@workspace:^
```

De esta forma, indicamos que instale un paquete llamado `core` que se encuentra en el workspace, para que lo busque directamente del monorepo y no en repositorios externos.

Una vez hecho esto, ya podremos utilizar en nuestras apps aquellos componentes que `core` exporte.

### Scripts en paralelo

Para ir finalizando este art√≠culo, vamos a ver una caracter√≠stica interesante de los monorepos que a√∫n no hemos comentado: la posibilidad de ejecutar todos los scripts a la vez y en paralelo. Si nos fijamos, los tres paquetes tienen un script dev. Es muy posible que cuando estemos desarrollando, queramos tener levantados estos entornos de desarrollo en los tres paquetes. Pnpm nos permite hacer esto de una forma muy sencilla. Simplemente tenemos que ir al package.json de ra√≠z y definir ah√≠ el siguiente script dev:

```txt
{
  // ---
  "scripts": {
    //---
    "dev": "pnpm run --parallel dev",
  },
}
```

Esto busca todos los scripts dev que haya en cada uno de los paquetes que conforman el monorepo y los ejecuta en paralelo.

Otra cosa interesante que nos ofrece `pnpm` es la posibilidad de filtrar un script a solo ciertos paquetes. Esto se hace utilizando la flag `--filter`. Esto nos permite crear scripts con las operaciones m√°s habituales de desarrollo que podamos necesitar. Por ejemplo, podr√≠amos configurar para levantar cada una de las apps por separado o las dos a la vez pero sin el paquete `core`.

```txt
{ 
  // ---
  "scripts": {
    //---
    "dev": "pnpm run --parallel dev",
    "dev:front": "pnpm run --filter front dev",
    "dev:api": "pnpm run --filter api dev",
    "dev:apps": "pnpm run --filter api --filter front dev"
  },
}
    
```

### Fin

Espero que este art√≠culo sirva como una introducci√≥n para empezar a trabajar con monorepos en TypeScript usando pnpm. He tratado de realizar paso a paso la configuraci√≥n que suelo utilizar para trabajar con este tipo de arquitecturas en proyectos TypeScript. Creo que puede servir como una buena base con la que empezar a construir proyectos usando este enfoque.

En posteriores art√≠culos del blog, utilizaremos esto como base para crear ciertos proyectos y/o explicar algunas t√©cnicas de desarrollo que suelo utilizar en mi d√≠a a d√≠a.

Por √∫ltimo, dejo por [aqu√≠](https://github.com/enolcasielles/monorepo) el link al repositorio en github en el que est√° implementado todo lo que hemos ido haciendo en este art√≠culo.