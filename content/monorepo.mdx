---
title: Monorepo con pnpm
publishedAt: '2024-01-22'
summary: >-
  En este art칤culo vamos a explicar las ventajas de utiliar un enfoque monorepo
  y ver un ejemplo de como construir uno
---

## Construyendo un Monorepo en Typescript utilizando pnpm

En este art칤culo vamos a explicar lo que es un Monorepo, porqu칠 es interesante utilizarlos para ciertos tipos de proyectos y c칩mo podemos construir uno utilizando pnpm.

### 쯈u칠 es un monorepo?

Un monorepo, como su nombre indica, es un repositorio que contiene m칰ltiples paquetes o partes de un sistema. Pensemos por ejemplo en una arquitectura b치sica de un proyecto web. Podr칤amos tener por un lado un proyecto de front y por otro lado un proyecto de back. Ambos ser칤an totalmente independientes entre s칤, contando con su propio repositorio, c칩digo fuente, dependencias, etc.&#x20;

Por el contrario cuando trabajamos con un monorepo estos 2 proyectos estar칤an bajo el mismo repositorio, seguir칤an siendo totalmente independientes pero tendr칤amos la capacidad de, en los escenarios que queramos, compartir ciertas cosas entre ellos.

### 쮺uando es interesante utilizarlos?

Para ilustrar bien esto, vamos a imaginar que el ejemplo del apartado anterior tenemos que extenderlo y crear un tercer proyecto. Este proyecto ser치 otra frontal que utilizar치 otro tipo de usuario, por ejemplo un panel de administraci칩n. No ser칤a de extra침ar que este nuevo front comparta componentes de UI con el otro front, 쯨erdad?&#x20;

쮺omo solucionamos esto cuando trabajamos en una arquitectura multirepo? Pues probablemente copiando estos componentes al nuevo proyecto, lo cual nos fuerza a que, a partir de este momento, tengamos que mantener componentes que son totalmente iguales en 2 sitios diferentes.&#x20;

Tendr칤a mucho m치s sentido que esos componentes puedan estar en alg칰n sitio que ambos proyectos puedan utilizar, sin necesidad de tenerlos duplicados. Algo como por ejemplo un paquete externo que los 2 proyectos importen. Pues bien, este es el tipo de cosas que un enfoque monorepo nos permite hacer de forma sencilla y organizada.

Cuando estos 2 proyectos viven bajo el mismo monorepo, podemos a침adir un tercer proyecto que se encargue de implementar estos componentes comunes y que sea importado por ambos frontales.

### 쯄e das otro ejemplo?

Otro ejemplo interesante es cuando quieres compartir clases o modelos entre front y back. Frecuentemente ocurre que en el back defines unas clases con los modelos de respuesta que las diferentes llamadas devolver치n y, a su vez, en el front defines otras clases para gestionar la respuesta.&#x20;

Estas clases seguramente sean duplicadas en amos proyectos por lo que tendr칤a mucho m치s sentido si se encuentran en un paquete independiente y que ambos proyectos puedan importar. De nuevo un caso que una arquitectura monorepo nos permite implementar y mantener de forma sencilla.

### 쮺칩mo puedo construir un monorepo?

Vista un poco la teor칤a y la justificaci칩n de porqu칠 es interesante este enfoque vamos a ver c칩mo podemos construir uno en Typescript utilizando la herramienta pnpm, que es una alternativa a npm que por su dise침o y funcionamiento encaja mucho mejor para la construcci칩n de este tipo de arquitecturas.

Para empezar, nos ponemos en la carpeta de trabajo ycreamos un nuevo proyecto vac칤o utilizando pnpm.

```txt
pnpm init
```

> Has de tener pnpm instalado en tu m치quina. En su [web oficial](https://pnpm.io/installation) puedes ver como instalarlo

Esto nos crear치 en la carpeta el t칤pico `package.json`. Hasta este punto lo que tenemos es un proyecto de node est치ndar gestionado por pnpm. Para convertirlo a un proyecto monorepo lo que tenemos que hacer es crear un fichero `pnpm-workspace.yaml`

```txt
packages:
  - "apps/*"
  - "packages/*"
```

Este fichero lo que hace es especificar en que rutas estar치n los distintos paquetes de nuestro monorepo. En esta caso definimos 2 posibles carpetas,  `apps` y `packages` por lo que podemos aprovechar ya para crear estas 2 carpetas en nuestro proyecto, que de momento las dejamos vac칤as. &#x20;

> Hacemos esta distinci칩n de carpetas para diferenciar las aplicaciones de lo que son los paquetes que van a ser utilizados por estas aplicaciones. Esto no es obligatorio, para el monorepo no hay distinci칩n alguna entre lo que es una app y lo que es un paquete, la hacemos nosotros por la diferencia conceptual de lo que representan. A partir de ahora cuando hablemos de un paquete ser치 aplicable a cualquiera de los 2 tipos, ya que realmente, es as칤 en la terminolog칤a utilizada en un monorepo con pnpm.

Como ya hemos comentado cada uno de los paquetes ser치n entidades independientes, nuevos proyectos pnpm que contar치n con su `package.json`, con su listado de dependencias, scripts personalizados, etc, etc. Pero lo que es importante destacar es que al estar en el monorepo ser치 este quien se encargue de gestionar las dependencias de cada uno de ellos. Esto quiere decir que, cuando instalamos una dependencia en alguno de los paquetes, ser치 el monorepo quien la instalar치 y quien decidir치 que el alcance de dicha dependencia es para dicho paquete y no para el resto. Ahora bien, 쯤u칠 pasa si instalamos una dependencia en el paquete ra칤z? Recordemos que el paquete ra칤z no deja de ser un proyecto pnpm tambi칠n, por lo que perfectamente se puede instalar algo a este nivel. Pues bien, lo que pasar치 es que dicha dependencia estar치 disponible en todos los paquetes.

Por lo general no querremos instalar dependencias en ra칤z pero s칤 que es habitual hacer alguna excepci칩n. Por ejemplo, algo que yo suelo hacer es instalar el typescript y configurar el eslint a este nivel de ra칤z. La raz칩n de hacer esto es que s칠 seguro que todos los paquetes se van a escribir en Typescript y que quiero unificar las reglas de escritura de c칩digo en todos ellos. Pero esto no tiene porqu칠 ser as칤, es una decisi칩n totalmente de cultura de ingenier칤a del proyecto.

### Instalando dependencias globales

Dicho lo anterior vamos a configurar estas dependencias visibles para todos los paquetes. Para ello simplemente nos tenemos que ubicar en la ra칤z del proyecto y ejecutar:

```txt
pnpm install typescript eslint -w
```

Importante destacar el uso de la flag -w. Cuando tratas de instalar algo en la ra칤z del monorepo, por defecto pnpm te lanza un warning para que tengas en cuenta que est치s en ra칤z. Como no es lo habitual instalar dependencias a este nivel, pnpm considera que puede ser un error y te advierte. Con la flag -w indicas que eres consciente de ello y que quieres instalarlo en ra칤z, evitando que te salte el aviso. Este comportamiento tambi칠n puede ser evitado estableciendo un ajuste en el proyecto, lo veremos m치s adelante.

Una vez hemos hecho esto ya podemos ver como estas 2 dependencias se instalan y aparecen en en el `package.json` de ra칤z. Vamos a proceder ahora a configurar `eslint`, para ello vamos a utilizar el configurador que la propia dependencia nos ofrece. Pero antes de hacer esto es importante que tengamos en cuenta algo. Como dec칤amos antes pnpm bloquea las instalaciones a nivel ra칤z si no llevan la flag -w. El configurador de `eslint`, a pesar de que s칤 permite la instalaci칩n usando pnpm, no utilizar치 esta flag -w, por lo que no podr치 finalizar correctamente. 쮺칩mo podemos solucionar esto? Estableciendo un ajuste que le indique a pnpm que ignore este warning. Esto se hace creando un fichero `.npmrc` e insertando la siguiente l칤nea:

```txt
ignore-workspace-root-check=true
```

Con esto el warning ser치 ignorado y se podr치 instalar en ra칤z sin la flag -w. Procedemos entonces a la configuraci칩n del eslint:

```txt
pnpm eslint --init
```

<Image
  alt={`Configuraci칩n eslint`}
  src={`/blog/monorepo/eslint.gif`}
  width={1280}
  height={720}
/>

El resultado de este configurador ser치 la instalaci칩n de las dependencias necesarias y la creaci칩n del fichero `.eslintrc.json` en la ra칤z del proyecto:

```txt
{
    "env": {
        "browser": true,
        "es2021": true,
        "node": true
    },
    "extends": "standard-with-typescript",
    "parserOptions": {
        "ecmaVersion": "latest",
        "sourceType": "module"
    },
    "rules": {
    }
}

```

En este punto tenemos todo listo para empezar a crear paquetes en el monorepo 游

### Definiendo el proyecto

Antes de empezar con la implementaci칩n de los diferentes paquetes, vamos a explicar brevemente el proyecto que a modo de ejemplo vamos a abordar. Ser치 algo muy sencillo ya que lo que queremos es focalizar en como funciona el monorepo y no en la aplicaci칩n en s칤 mismo. Por esa raz칩n no voy a entrar en detalle en nada referente a la implementaci칩n de la aplicaci칩n. Solo mencionar que ser치 la t칤pica App lista de tareas, con un front hecho con `React + Vite` y una Api hecha con `Express`, ambos proyectos en Typescript.&#x20;

Adem치s, para ilustrar mejor como usar un monorepo, crearemos un paquete llamado `core` que ser치 consumido por ambas apps y que definir치 clases o tipos que ambos puedan necesitar.

> En el enlace al repo que dejo al final del art칤culo pod칠is ver la implementaci칩n completa de cada parte.

### Creando el primer paquete

Vamos a empezar con la creaci칩n de la app para el front. Nos vamos a la carpeta `app` y creamos un proyecto React usando Vite:

```txt
pnpm create vite@latest front -- --template react-ts
```

Seguimos las instrucciones del configurador para crear el proyecto React con Typescript e instalar todos los paquetes necesarios. Si tras instalarlo nos vamos a `apps/front` y hacemos `pnpm run dev` deber칤amos poder lanzar correctamente el proyecto React en ejecuci칩n. Vamos a hacer ahora algunas modificaciones para adaptarlo mejor al monorepo.

Antes que nada, vamos a decirle a vite que utilice el puerto 3000 para nuestro front, en lugar de una aleatorio como hace por defecto. Nos vamos al `vite.config.ts` y agregamos el siguiente objeto `server`:

```txt
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000,
  }
})
```

A continuaci칩n vamos a adaptar el proyecto un poco mejor para vivir en el monorepo. La instalaci칩n por defecto de Vite configurar치 su propio typescript y eslint, pero como hemos comentado, nosotros queremos usar el del monorepo. Por tanto lo que haremos es desinstalar localmente estas dependencias y eliminar todos los ficheros. Nos vamos al `package.json` y eliminamos las siguientes dependecias:

```txt
typescript
eslint
@typescript-eslint/eslint-plugin
@typescript-eslint/parser
```

> En el momento de escribir este art칤culo estas eran las dependencias relacionadas con typescript o eslint que vite instalaba por defecto. Puede que en tu caso esto cambie un poco seg칰n la versi칩n de Vite utilizada, aseg칰rate de eliminar todas aquellas que tengan que ver con estas herramientas.

Una vez eliminadas en el `package.json` ejecutamos `pnpm install` en `apps/front` para que la desinstalaci칩n se lleve a cabo. Por 칰ltimo eliminamos el fichero `.eslintrc `para que no utilice la configuraci칩n de eslint que ah칤 se indica. Tras hacer esto nuestro proyecto front ya deber칤a coger las reglas de eslint definidas en ra칤z.&#x20;

Ahora bien, s칤 que es cierto que, seg칰n el tipo de proyecto Typescript en el que estemos, quiz치 nos interese tener alguna configuraci칩n diferente. Por ejemplo, este paquete front es una aplicaci칩n con React y en este caso es muy com칰n instalar el plugin de eslint para React `eslint-plugin-react` , pero no tiene sentido que instalemos este plugin en ra칤z y que nuestro proyecto `api` tambi칠n estar칤a expuesto a lo que dicte este plugin. Por tanto aqu칤 vamos a ver otro tema interesante que es como se puede adaptar la configuraci칩n de eslint para cada proyecto.&#x20;

Primero instalamos a este nivel `front` el paquete con el plugin mencionado

```txt
pnpm install -D eslint-plugin-react
```

Luego creamos otro fichero `.eslintrc.json` a nivel `front` y agregamos en 칠l lo siguiente:

```txt
{
  "extends": [
    "../../.eslintrc", 
    "plugin:react/recommended"
  ],
  "plugins": [
      "react"
  ],
  "rules": {}
}
```

As칤 le estamos indicando lo siguiente. Por un lado que utilice dicho plugin para React. Por otro lado que extienda de la configuraci칩n que tenemos definida en ra칤z. Y por 칰ltimo que extienda tambi칠n de lo que nos define el propio plugin. Finalmente, al igual que hemos hecho en ra칤z, definimos unas reglas personalizadas que por el momento estar치n vac칤as.

&#x20;Si utilizas VSCode y la extensi칩n para eslint, en este momento te deber칤an aparecer errores en tus archivos. Por ejemplo, podemos abrir el `App.tsx` y ver como hay varios errores de sintaxis. Esto es debido a que ahora la configuraci칩n de eslint es la que viene de Standard, la gu칤a de estilos que decidimos elegir cuando configuramos eslint en ra칤z, extendida adem치s por la del plugin de React que le acabamos de a침adir. Entonces tenemos que adaptar nuestro c칩digo para cumplir con esto. Tenemos 2 opciones para abordarlo: arreglar los errores que nos indica o modificar las reglas definidas. Esto de nuevo ya es una decisi칩n que has de tomar seg칰n como quieras afrontar tu desarrollo.

En mi caso lo que har칠 ser치 una mezcla de ambas opciones. A침adir칠 las siguientes 3 reglas a la configuraci칩n de eslint en ra칤z:

```txt
{
  //...
  "rules": {
    "@typescript-eslint/explicit-function-return-type": "off",
    "@typescript-eslint/no-floating-promises": "off",
    "@typescript-eslint/no-misused-promises": "off"
  }
}
```

Y a침adir칠 la siguiente a la configuraci칩n del proyecto front:

```txt
{
  //...
  "rules": {
    "react/react-in-jsx-scope": "off"
  }
}
```

Y una vez hecho esto corregir칠 el resto de errores o warnings que eslint me indique.

En este punto ya tenemos todo listo para crear nuestra App. Como dec칤a anteriormente no vamos  a entrar en detalles de la implementaci칩n, puedes ir al repo y ver como est치 hecho.

### Creando otro paquete para la Api

Ahora que ya hemos visto como crear y adaptar un proyecto al monorepo vamos a hacer lo mismo para la Api. Como hab칤amos dicho implementaremos una Api usando Express.

Nos vamos a la carpeta `apps` y creamos un nuevo directorio llamada `api`. En este caso no usaremos ning칰n generador. Entramos en la carpeta `api` y creamos un nuevo proyecto pnpm vac칤o.

```txt
mkdir api && cd api && pnpm init
```

Instalamos las dependencias necesarias

```txt
pnpm add express
pnpm add -D @types/express @types/node nodemon ts-node
```

B치sicamente lo que estamos haciendo es instalar express y como dependencias de desarrollo:

* Los tipos de express y node
* nodemon, que es una herramienta que nos permite f치cilmente hacer que el servidor se recargue al guardar cambios en los ficheros&#x20;
* ts-node, que b치sicamente digamos que nos permite ejecutar directamente el typescript

Agregamos un fichero `nodemon.json` en ra칤z para especificar como ha de funcionar esta herramienta

```txt
{
  "watch": ["src"],
  "ext": "ts",
  "exec": "ts-node ./src/index.ts"
}
```

Lo que aqu칤 le estamos diciendo es que ha de escuchar a los ficheros en la carpeta `src` con extensi칩n .ts para que, cada vez que se guarde uno de ellos, ejecute ts-node en el fichero principal. Con eso lo que conseguimos es ejecutar directamente la api con typescript (ts-node se encarga por debajo de todo) y hacer que se recargue con cada cambio (nodemon se encarga)

Agregamos tambi칠n el fichero `tsconfig.json` para indicar como se ha de realizar el transpilado a javascript, as칤 como algunas reglas de linting.

```txt
{
  "compilerOptions": {

    "module": "commonjs",
    "target": "ES2020",
    "outDir": "./dist",
    "incremental": true,
    "allowSyntheticDefaultImports": true,
    
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

  }
}


```

Por 칰ltimo creamos los scripts en el package.json para realizar el dev, el build y el start.

```txt
{
  // ---
  "scripts": {
    //---
    "build": "tsc",
    "start": "node dist/index.js",
    "dev": "nodemon"
  },
}
```

### Creando un paquete compartido

Lo siguiente que vamos a hacer es crear el paquete `core`, en el que implementaremos aquellas cosas que puedan ser comunes en ambas aplicaciones front y api. Creamos una nueva carpeta en `packages` llamada `core` y estando en ella creamos de nuevo un proyecto pnpm b치sico.&#x20;

```txt
pnpm init
```

A continuaci칩n creamos el `tsconfig.json` para especificar a typescript como ha de realizar el compilado a javascript.

```txt
{
  "compilerOptions": {

    "module": "ESNext",
    "target": "ES2015",
    "outDir": "./dist",
    "incremental": true,
    "allowSyntheticDefaultImports": true,
    "isolatedModules": true,
    
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "removeComments": true,
    
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

  }
}

```

> Esta configuraci칩n es similar  a la del proyecto api. En este caso como sistema de m칩dulos usamos ESNext que lo har치 m치s compatible para ser importado por las diferentes apps. Adem치s agregamos algunas propiedades que permiten generar las declaraciones de tipos y los ficheros de mapas entre el c칩digo fuente y el c칩digo compilado. Esto es interesando ya que ayuda el IDE a entender la estructura del paquete y facilita cosas como ir a la definici칩n de aquello que el paquete exporte cuando lo estamos usando en otro paquete.

Creamos tambi칠n en este paquete un `nodemon.json` para poder realizar el compilado en modo desarrollo:

```txt
{
  "watch": ["src"],
  "ext": "ts",
  "exec": "npm run build"
}
```

Y finalmente agregamos los scripts para hacer el build y el dev en el package.json

```txt
{
  // ---
  "scripts": {
    //---
    "build": "tsc -p tsconfig.json",
    "dev": "nodemon"
  },
}

```

Y con esto ya tenemos tambi칠n listo este paquete para escribir el c칩digo que necesitemos.&#x20;

### Importando el paquete

Lo 칰nico que tenemos que hacer ahora es importar el paquete `core` en las apps. Esto lo hacemos como cualquier otro paquete, nos vamos al directorio de cada una de las apps y hacemos:

```txt
pnpm add core@workspace:^
```

De esta forma lo que estamos indicando es que instale un paquete llamado `core` y que se encuentra en el workspace, para que lo busque directamente del monorepo y no en repositorios externos.

Una vez hecho esto ya podremos utilizar en nuestras apps aquellos componentes que `core` exporte.

### Scripts en paralelo

Para ir finalizando este art칤culo vamos a ver una cosa interesante de los monorepos que a칰n no hemos comentado, la posibilidad de ejecutar todos los scripts a la vez y en paralelo. Si nos fijamos, los 3 paquetes tienen un script dev. Es muy posible que cuando estemos desarrollando queramos tener levantados estos entornos de desarrollo en los 3 paquetes. Pues pnpm nos permite hacer esto de una forma muy sencilla. Simplemente tenemos que ir al package.json de ra칤z y definir ah칤 el siguiente script dev

```txt
{
  // ---
  "scripts": {
    //---
    "dev": "pnpm run --parallel dev",
  },
}
```

Esto lo que hace es buscar todos los scripts dev que haya en cada uno de los paquetes que conforman el monorepo y ejecutarlos en paralelo.

Otra cosa interesante que nos ofrece pnpm  es la de poder filtrar un script a solo ciertos paquetes. Esto se hace utilizando el flag --filter. Esto nos da juego a que creemos scripts con las operaciones m치s habituales de desarrollo que podamos necesitar. Por ejemplo podr칤amos configurar para levantar cada una de las apps por separado o las 2 a la vez pero sin el paquete core

```txt
{ 
  // ---
  "scripts": {
    //---
    "dev": "pnpm run --parallel dev",
    "dev:front": "pnpm run --filter front dev",
    "dev:api": "pnpm run --filter api dev",
    "dev:apps": "pnpm run --filter api --filter front dev"
  },
}
    
```

### Fin

Espero que este art칤culo sirva como una introducci칩n para empezar a trabajar con monorepos en typescript usando pnpm. He tratado de realizar paso a paso la configuraci칩n que yo suelo utilizar para trabajar con este tipo de arquitecturas en proyectos typescript. Creo que puede servir como una buena base con la que empezar a construir proyectos usando este enfoque.&#x20;

En los siguientes art칤culos del blog utilizaremos esto como base para crear ciertos proyectos y/o explicar algunas t칠cnicas de desarrollo que suelo utilizar en mi d칤a a d칤a.

Por 칰ltimo, dejo por aqu칤 el [link](https://github.com/enolcasielles/monorepo) al repo en github en el que est치 implementado todo lo que hemos ido haciendo.