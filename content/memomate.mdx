---
title: 'C√≥mo Desarroll√© MemoMate: Un Asistente Personal en Telegram con IA'
publishedAt: '2024-12-04'
summary: 'MemoMate es un bot de Telegram que act√∫a como un PRM (Personal Relationship Manager). A trav√©s de una conversaci√≥n natural, puedes contarle informaci√≥n sobre tus contactos, y el bot se encarga de almacenar y organizar esta informaci√≥n de forma que la puedas usar f√°cilmente en el futuro.'
---

## Introducci√≥n

En este art√≠culo quiero compartir mi experiencia desarrollando **MemoMate**, un asistente personal en Telegram que ayuda a gestionar y mejorar nuestras relaciones personales. La idea surgi√≥ de una necesidad personal: tener una forma sencilla de recordar detalles importantes sobre las personas que me importan - desde cumplea√±os hasta conversaciones significativas.

## ¬øQu√© es MemoMate?

MemoMate es un bot de Telegram que act√∫a como un PRM (Personal Relationship Manager). A trav√©s de una conversaci√≥n natural, puedes contarle informaci√≥n sobre tus contactos, y el bot se encarga de almacenar y organizar esta informaci√≥n de forma que puedas acceder a ella en el futuro. Vamos a ver aqu√≠ sus principales caracter√≠sticas.

### Gesti√≥n de Contactos

Durante tu conversaci√≥n con el bot, este ir√° detectando los contactos sobre los que est√°s hablando y los ir√° registrando en tu cuenta. Tendr√° la capacidad de saber si el contacto ya existe en la base de datos y, en caso de que no, lo crear√°. Tambi√©n puedes pedirle que edite cualquier informaci√≥n sobre un contacto o incluso que lo elimine.

### Informaci√≥n sobre Contactos

El bot est√° preparado para que le cuentes cualquier cosa que necesites recordar sobre cualquiera de tus contactos. El bot ir√° almacenando toda esta informaci√≥n para que m√°s tarde puedas consultarla. Vamos a verlo con un ejemplo:

Imagina que tienes un amigo que se llama Jos√© y que el bot ya lo tiene registrado como un contacto tuyo. Podr√≠as decirle algo como:

> "Ayer estuve con mi amigo Jos√© y me coment√≥ que se est√° planteando dejar su trabajo"

Ahora imagina que pasan 3 meses y vas a quedar con tu amigo Jos√©. Podr√≠as ir a MemoMate y preguntarle:

> "¬øQu√© me cont√≥ mi amigo Jos√© la √∫ltima vez?"

El bot te responder√° diciendo:

> "Jos√© te dijo que se est√° planteando dejar su trabajo"

### Recordatorios

Otra funcionalidad interesante del bot es la de los recordatorios. MemoMate te permite registrar recordatorios sobre cualquier contacto, para que te env√≠e un mensaje en la fecha asignada. Por ejemplo, podr√≠as decirle:

> "El pr√≥ximo 15 de diciembre es el cumplea√±os de mi amigo Jos√©. Recu√©rdame que le felicite"

El bot interpretar√° de este mensaje que tiene que crear un recordatorio para el pr√≥ximo 15 de diciembre sobre el contacto Jos√© y para que le felicites. Cuando llegue dicha fecha, el bot te enviar√° un mensaje como:

> "Recuerda felicitar a Jos√© por su cumplea√±os"

### Free vs Premium

MemoMate se podr√° utilizar de forma gratuita, lo que permitir√° un uso limitado de la cuenta. Cada usuario tendr√° un n√∫mero de mensajes que puede enviar al bot cada mes. Cuando agote estos mensajes, el usuario no podr√° enviar m√°s mensajes hasta que no se le renueven sus cr√©ditos o pase a Premium. Cuando se hace Premium, el usuario desbloquea la limitaci√≥n de mensajes y puede hacer un uso ilimitado.

### Plataforma Web

Adem√°s del bot en Telegram, MemoMate tambi√©n cuenta con una plataforma web que otorga al usuario ciertas funcionalidades:

* **Gesti√≥n de la suscripci√≥n**: A trav√©s de esta web el usuario podr√° controlar la suscripci√≥n que convierte al usuario en Premium.
* **Gesti√≥n de Contactos**: Adem√°s de la gesti√≥n de contactos que realiza el propio bot, el usuario contar√° con una secci√≥n en la web en la que tambi√©n pueda realizar esta gesti√≥n y con una caracter√≠stica extra importante: importaci√≥n v√≠a csv.
* **Gesti√≥n de Eventos:** Lo mismo para la informaci√≥n de los contactos. El usuario podr√° ver y gestionar esta informaci√≥n tambi√©n desde la aplicaci√≥n web.
* **Anal√≠ticas:** La aplicaci√≥n web le dar√° al usuario algunos datos interesantes acerca del uso de su cuenta.
* **Landing Page Promocional**: Esta Web tambi√©n cuenta con la p√°gina explicativa del producto que servir√≠a para promocionar y explicar el mismo al usuario.

## Arquitectura y Tecnolog√≠as

MemoMate se compone de 2 componentes (o aplicaciones) principales:

1. **Bot de Telegram**: para manejar toda la interacci√≥n con los usuarios.
2. **Aplicaci√≥n Web**: para que el usuario pueda gestionar su cuenta y los contactos.

### Tecnolog√≠as empleadas

Vamos a ver aqu√≠ las tecnolog√≠as que he decidido emplear para implementar este producto y el porqu√© de cada una.

* **Monorepo con pnpm**: Ambas aplicaciones (bot y web) tienen funcionalidad que es interesante compartir. Por esta raz√≥n, decid√≠ utilizar una arquitectura de monorepo en el que vivan estas 2 aplicaciones y que cuente con paquetes que definan las funcionalidades que se deban compartir. PNPM fue la elecci√≥n natural por su eficiencia en el manejo de dependencias y su excelente soporte para workspaces. Si quieres saber m√°s sobre este tema te recomiento [este art√≠culo](https://www.enolcasielles.com/blog/monorepo) donde explico m√°s en detalle.
* **PostgreSQL + Prisma**: Necesitaba una base de datos robusta que pudiera manejar relaciones complejas entre usuarios, contactos y eventos. PostgreSQL fue el candidato perfecto. Prisma a√±ade una capa que nos facilita tanto el manejo de las migraciones como la implementaci√≥n de las diferentes comunicaciones con la base de datos que sean necesarias.
* **OpenAI**: La API de OpenAI, especialmente con sus Assistants, ofrece capacidades avanzadas de procesamiento de lenguaje natural. La posibilidad de definir "tools" personalizadas que el asistente puede utilizar fue clave para implementar las funcionalidades principales del bot.
* **Next.js**: Para la aplicaci√≥n web, Next.js fue la elecci√≥n ideal por varios motivos:
  * Server Components para mejor rendimiento.
  * App Router para la implementaci√≥n de las diferentes secciones.
  * API Routes para implementar los endpoints serverless que necesitemos.
* **Tailwind CSS y Shadcn**: A la hora de definir la UI de la aplicaci√≥n web, esta combinaci√≥n es perfecta por la facilidad que otorga a la hora de crear los diferentes componentes de una forma robusta y eficiente.
* **Pinecone**: Para implementar b√∫squedas sem√°nticas sobre la informaci√≥n de los contactos, necesit√°bamos una base de datos vectorial. Pinecone destaca por su facilidad de uso, rendimiento y capacidad para manejar grandes vol√∫menes de datos vectoriales.
* **Telegraf:** Para implementar el bot de telegram, optamos por utilizar la librer√≠a telegraf que destaca por su buen funcionamiento y facilidad de integraci√≥n.

## El Proceso de Desarrollo

Vamos a explicar ahora como se ha abordado el proceso de desarrollo del proyecto, pasando por todos los pasos que se han ido dando para llegar desde una idea inicial hasta un producto final. No vamos a entrar en detalle de absolutamente todas las piezas de c√≥digo que se fueron desarrollando, ya que har√≠amos el art√≠culo excesivamente extenso. Voy a ir explicando como se fueron definiendo las diferentes partes y par√°ndome en aquellas que considero m√°s interesantes. Recomiendo abrir el [repositorio del proyecto](https://github.com/enolcasielles/memo-mate) y ver en m√°s detalle la implementaci√≥n realizada.

### Definici√≥n del Proyecto

Este proceso comenz√≥ definiendo claramente el alcance y la arquitectura. Apoy√°ndome mucho en ChatGPT fu√≠ refinando la idea y documentando como √≠bamos a realizar cada parte. El objetivo aqu√≠ era crear diferentes documentos que iba volcando en la carpeta `docs`. Esta fase de planificaci√≥n fue crucial para tener una visi√≥n clara del camino a seguir y para poder disponer de la informaci√≥n necesaria para llevar a cabo un [desarrollo eficiente con Cursor](https://www.enolcasielles.com/blog/using-cursor). En esta carpeta creamos diferentes documentos: explicaci√≥n del proyecto, definici√≥n de la base de datos, arquitectura, etc. Esto nos permite que Cursor tenga conocimiento de lo que estamos desarrollando y nos ayude a iterar mucho m√°s r√°pido.

### Estructura Base

Se utiliz√≥ una arquitectura de monorepo con los diferentes componentes. Por un lado las 2 aplicaciones que ya mencionamos (el bot y la web) y por otro lado los diferentes paquetes en los que se apoyar√°n estas aplicaciones. Tambi√©n contamos con una aplicaci√≥n extra que llamamos `infra`. Esta aplicaci√≥n ser√° b√°sicamente un docker-compose que nos permite levantar la infra en local que necesitemos, en este caso √∫nicamente la base de datos PostgreSQL.&#x20;

> A pesar de tener un √∫nico servicio en la infra, decidimos mantener un docker-compose para facilitar el agregar posibles servicios a futuro

En cuanto a los paquetes, tendremos los siguientes:

* `core`: En donde implementaremos utilidades compartidas
* `database`: Que se encargar√° de gestionar todo lo que tenga que ver con la base de datos usando Prisma. Modelos, migraciones, etc.
* `openai`: Abstracci√≥n para la interacci√≥n con OpenAI. Definiremos en esta paquete clases y utilidades interesantes que nos facilitar√°n al creaci√≥n y gesti√≥n del Asistente en OpenAI.

### Sistema de Autenticaci√≥n

El sistema de autenticaci√≥n de la plataforma es algo inusual. La idea no es contar con un mecanismo de Login y Registro al uso, si no que sea el bot quien se encargue de gestionar esto. El bot tendr√° la capacidad de identificar al usuario con el que est√° interactuando, creando usuarios nuevos en cada nueva conversaci√≥n. Cuando el usuario tenga que ir a la plataforma web, tanto porque el bot se lo requiere o porque el usuario desea hacerlo, el bot ser√° el responsable de generar un link √∫nico y temporal de acceso.

Para conseguir esto, se desarroll√≥ un sistema de autenticaci√≥n simple pero efectivo. El flujo funciona as√≠:

1. Cuando el usuario necesita acceder a la web, el bot genera una sesi√≥n temporal con un token √∫nico. Ese link ser√° v√°lido solo durante 10 minutos (expiraci√≥n de la sesi√≥n).

```tsx
  private async createSessionUrl(userId: string) {
    const session = await prisma.session.create({
      data: {
        userId: userId,
        expiresAt: new Date(Date.now() + 1000 * 60 * 10),
      }
    });
    const link = `${process.env.FRONTEND_URL}/login?token=${session.id}`;
    return link;
  }
```

1. El bot env√≠a este link al usuario para que pueda hacer clic en el, lo cual disparar√° la Api Route `/login` en la web. Esta ruta har√° lo siguiente:
   * Verificar que el token sea v√°lido y no haya expirado
   * Si es v√°lido, crea una cookie de 30 d√≠as y redirige a `/dashboard`
   * Si no es v√°lido, redirige a una p√°gina de error

```tsx
export async function LoginRoute(request: Request) {
  const { searchParams } = new URL(request.url);
  const token = searchParams.get("token");
  let errorType = null;
  try {
    if (!token) {
      throw new CustomError({
        message: "Token no proporcionado",
        type: "INVALID_TOKEN",
        statusCode: 400,
      });
    }
    const session = await prisma.session.findFirst({
      where: {
        id: token,
        expiresAt: {
          gt: new Date(),
        },
      },
      include: {
        user: true,
      },
    });

    if (!session) {
      throw new CustomError({
        message: "Sesi√≥n inv√°lida o expirada",
        statusCode: 401,
        type: "INVALID_TOKEN",
      });
    }

    // Crear cookie con el ID del usuario
    cookies().set("userId", session.userId, {
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax",
      path: "/",
      maxAge: 60 * 60 * 24 * 30, // 30 d√≠as
    });

    // Retornamos una redirecci√≥n
    return NextResponse.redirect(new URL("/dashboard", request.url));
  } catch (error) {
    console.error(error);
    if (error instanceof CustomError) errorType = error.type;
    else errorType = "INTERNAL_SERVER_ERROR";
  }
  redirect(`/error?type=${errorType}`);
}
```

De esta forma, conseguimos un mecanismo sencillo pero seguro y efectivo para que el usuario pueda acceder a su cuenta en la web desde Telegram. El usuario una vez identificado, ya podr√° volver a su cuenta siempre que quiera (durante 30 d√≠as) simplemente accediendo a la web. Cuando la cookie caduque, deber√° volver al bot para generar un nuevo link de acceso.

### Integraci√≥n con OpenAI

Para manejar la interacci√≥n con OpenAI de forma limpia y reutilizable, se cre√≥ un paquete dedicado `@memomate/openai` que abstrae toda la complejidad de la API. Este paquete implementa cuatro clases principales:

#### Agent

La clase `Agent` representa un asistente de OpenAI y maneja su ciclo de vida. Para poder utilizar los Asistentes de OpenAI lo primero que necesitas es crear uno, que lo puedes hacer usando su API o directamente a trav√©s de su [plataforma](https://platform.openai.com/assistants). En nuestro caso, creamos el asistente directamente en la plataforma y metimos su id como una variable de entorno para poder recuperarlo a trav√©s de la API, dentro de esta clase `Agent`

El asistente es la entidad en OpenAI a la que se le especifica su prop√≥sito y como debe operar. Tambi√©n se le especifica el modelo que debe utilizar, as√≠ como las herramientas que tiene disponibles para extender funcionalidad.&#x20;

```tsx
interface Props {
  id: string;
  name: string;
  description: string;
  instructions: string;
  model?: string;
  tools: Array<Tool>;
}

export class Agent {
  // ...
  async init() {
    let openAiAssistant = await openaiClient.beta.assistants.retrieve(this.id);
    const shouldUpdate = this.shouldUpdate(openAiAssistant);
    if (shouldUpdate) {
      openAiAssistant = await openaiClient.beta.assistants.update(
        this.id,
        this.generateBody()
      );
    }
    this.assistant = openAiAssistant;
  }
}
```

Esta clase Agent tambi√©n cuenta con una funcionalidad para comprobar si el asistente debe ser actualizado en OpenAI o no. La idea es que podamos desde el propio c√≥digo del proyecto especificar como debe comportarse el asistente. El m√©todo `shouldUpdate`, compara los par√°metros del Asistente en OpenAI con lo que hemos especificado en local (modelo, instrucciones, tools empleadas, etc.) Si detecta diferencias, actualizar√° el asistente en OpenAI, garantizando que desde el propio c√≥digo controlemos su comportamiento.

```tsx
  private shouldUpdate(openAiAssistant: Assistant): boolean {
    if (this.name !== openAiAssistant.name) return true;
    if (this.description !== openAiAssistant.description) return true;
    if (this.instructions !== openAiAssistant.instructions) return true;
    if (this.model !== openAiAssistant.model) return true;
    if (this.tools.length !== openAiAssistant.tools.length) return true;
    return false;
  }
```

#### Tool

Los asistentes est√°n capacitados para ejecutar herramientas o tools, que son piezas de c√≥digo que nos permiten llevar a cabo acciones que el propio Asistente no puede realizar por s√≠ mismo. Por ejemplo, en nuestro caso, necesitaremos una Tool que cree un nuevo contacto. Para conseguir esto, lo que se hace es, primero especificarle al asistente que cuenta con una tool para crear un contacto y como la debe utilizar. Y, por otro lado, crear la propia tool para implementar dicha creaci√≥n de usuario.&#x20;

Para dar soporte a esto, la case abstracta `Tool` define la estructura para las herramientas que puede usar el asistente:

```tsx
export abstract class Tool {
  name: string;
  description: string;
  parameters: any;

  constructor({ name, description, parameters }: ToolParams) {
    this.name = name;
    this.description = description;
    this.parameters = parameters;
  }

  abstract run(parameters: RunProps): Promise<string>;
}
```

Cada Tool que necesitemos crear y agregar al Agente, tendr√° que ser una extensi√≥n de esta clase y deber√° implementar el m√©todo `run` para realizar su funci√≥n.

#### Thread

El siguiente concepto para comunicarnos con los asistentes de OpenAI es el `Thread` o hilo comunicaci√≥n, que b√°sicamente es cada conversaci√≥n que tenga el Asistente. La idea en MemoMate es que cada usuario tenga su Thread propio, que se crear√° a la vez que la creaci√≥n del usuario y permitir√° mantener su propia conversaci√≥n.

La clase `Thread` que implementamos en este paquete `@memomate/openai` se encarga de implementar toda esta funcionalidad. B√°sicamente nos permite lo siguiente:

* Crear un nuevo hilo. Lo usaremos cuando se cree un nuevo usuario.

```tsx
  static async create() {
    const thread = await openaiClient.beta.threads.create();
    return thread.id;
  }
```

* Enviar un mensaje a un hilo. Se disparar√° con cada nuevo mensaje del usuario, a su hilo correspondiente.

```tsx
  async send(message: string, retries: number = 1): Promise<string> {
    if (!this.agent) throw new Error("Assistant not set");
    if (!this.thread) await this.init();
    await openaiClient.beta.threads.messages.create(this.id, {
      role: "user",
      content: message,
    });
    this.run = await openaiClient.beta.threads.runs.create(this.id, {
      assistant_id: this.agent.id,
    });
    while (true) {
      await this.waitUntilDone();
      if (this.run.status === "completed") {
        const _message = await this.extractMessage();
        return _message;
      } else if (this.run.status === "requires_action") {
        await this.processAction();
      } else {
        const err = "Run failed: " + this.run.status;
        console.log(err);
        if (retries < MAX_RETRIES) {
          console.log("Retrying in 30s...");
          await new Promise((resolve) => setTimeout(resolve, 30000));
          return this.send(message, retries + 1);
        }
        const _message = this.generateFailedMessage();
        return _message;
      }
    }
  }
```

Dentro de este m√©todo `send`, se procesa la respuesta que nos da OpenAI, que puede ser un mensaje a devolver o una herramienta a ejecutar. Cuando sea una herramienta a ejecutar, buscaremos la herramienta correspondiente dentro de las tools del Agente y ejecutaremos su m√©todo `run`, devolviendo al asistente el resultado de dicha ejecuci√≥n para que pueda continuar y entregar al usuario una respuesta final.

```tsx
  private async processAction() {
    const toolsToExecute =
      await this.run.required_action.submit_tool_outputs.tool_calls;
    const toolsResults = [];
    for (const toolToExecute of toolsToExecute) {
      const toolName = toolToExecute.function.name;
      const tool = this.agent.tools.find((t) => t.name === toolName);
      const toolResult = tool
        ? await tool.run({
            ...JSON.parse(toolToExecute.function.arguments),
            metadata: this.metadata,
          })
        : "ERROR: no existe ninguna herramienta con el nombre que has indicado. Int√©ntalo de nuevo con el nombre correcto. La lista de herramientas disponibles es la siguiente: " +
          this.agent.tools.map((t) => t.name).join(", ");
      toolsResults.push({
        tool_call_id: toolToExecute.id,
        output: toolResult.toString(),
      });
    }
    this.run = await openaiClient.beta.threads.runs.submitToolOutputs(
      this.id,
      this.run.id,
      {
        tool_outputs: toolsResults,
      },
    );
  }
```

#### Embeddings

Otro concepto que necesitamos de OpenAI es el de los embeddings, que es la transformaci√≥n de cierto texto en un formato vectorial que nos permita realizar b√∫squedas sem√°nticas. Esto lo usaremos para poder recuperar los contactos del usuario. Cada vez que se cree o se actualice un contacto, generaremos su embedding correspondiente y lo guardaremos en Pinecone, para poder buscarlo en el futuro.

Para maneja esta generaci√≥n de embeddings hemos creado esta clase `Embeddings`

```tsx
export class Embeddings {
  private model = 'text-embedding-3-small';
  private dimensions = 1024;

  async generateEmbedding(text: string): Promise<number[]> {
    const response = await openaiClient.embeddings.create({
      model: this.model,
      dimensions: this.dimensions,
      input: text,
      encoding_format: 'float'
    });

    return response.data[0].embedding;
  }
}
```

De esta forma, el paquete `@memomate/openai` nos proporciona una capa de abstracci√≥n sobre la API de OpenAI, facilitando su uso y permitiendo una mayor flexibilidad en futuras implementaciones.

### Implementaci√≥n del Asistente

Una vez contamos con este paquete `@memomate/openai` ya estamos en disposici√≥n de proceder con la implementaci√≥n del Asistente. En la aplicaci√≥n bot, creamos una nueva carpeta `assistant` que se encargue de esto.&#x20;

Empezamos con las tools, o las herramientas que le daremos al asistente para que pueda realizar las diferentes acciones necesarias: Crear un Contacto, Buscar un Contacto, Crear un Evento, etc. Cada herramienta ser√° una clase que extienda de la clase abstracta Tool. El m√©todo `run` ser√° el que se ejecuta cuando el asistente detecte que debe usar esta Tool. Y por tanto, en este m√©todo `run` es donde definimos lo que queremos que esta Tool realice.

```tsx
export class CreateContactTool extends Tool {
  constructor() {
    super({
      name: "CreateContact",
      description:
        "Esta herramienta crea un nuevo contacto en la base de datos.",
      parameters: {
        type: "object",
        properties: {
          name: {
            type: "string",
            description:
              "El nombre del contacto que se desea crear.",
          },
          relation: {
            type: "string",
            description:
              "La relaci√≥n del contacto con el usuario. Ejemplo: 'Amigo', 'Familiar', 'Trabajo', etc.",
          },
          location: {
            type: "string",
            description:
              "La ubicaci√≥n del contacto. Puede ser una ciudad, un pa√≠s, etc. Ejemplos: 'Madrid', 'Asturias', 'Argentina', etc.",
          },
        },
        required: ["name"],
      },
    });
  }

  async run(parameters: CreateContactRunProps): Promise<string> {
    try {
      console.log("Creando contacto...");
      const { metadata, name, relation, location } = parameters;
      
      // Crear el contacto en la base de datos
      const contact = await prisma.contact.create({
        data: {
          name,
          relation,
          location,
          userId: metadata.userId
        }
      });

      // Generar el texto para el embedding
      const contactText = `Nombre: ${name}${relation ? `, Relaci√≥n: ${relation}` : ''}${location ? `, Ubicaci√≥n: ${location}` : ''}`;
      
      // Generar embedding usando OpenAI
      const embeddings = new Embeddings();
      const embeddingValue = await embeddings.generateEmbedding(contactText);
      
      // Indexar en Pinecone
      await PineconeService.getInstance().upsertContact(
        metadata.userId,
        contact.id,
        embeddingValue
      );

      return `He creado el contacto ${name} correctamente. Su ID es ${contact.id}.`;
    } catch (e) {
      console.error(e);
      return `No se ha podido crear el contacto.`;
    }
  }
}
```

A continuaci√≥n, creamos los archivos de texto `instructions.md` y `description.md` (formato markdown), para definir la descripci√≥n y las instrucciones de nuestro asistente. Aqu√≠ es donde le explicamos a nuestro asistente como debe actuar para llevar a cabo su prop√≥sito.

Y ya por √∫ltimo, creamos la clase `MemoMateAssistant`, que ser√° la que se encargue de crear e inicializar el agente juntando todas las anteriores piezas y de exponer un m√©todo `sendMessage` que permita enviarle un nuevo mensaje a este Agente usando el hilo del usuario en cuesti√≥n.

```
export class MemoMateAssistant {
  private agent: Agent;
  private static instance: MemoMateAssistant;

  private constructor() {
    this.agent = new Agent({
      id: process.env.OPENAI_ASSISTANT_ID,
      name: "MemoMate Assistant",
      description: path.join(__dirname, "description.md"),
      instructions: path.join(__dirname, "instructions.md"),
      model: "gpt-4o-mini",
      tools: [
        new CreateContactTool(),
        new UpdateContactTool(),
        new DeleteContactTool(),
        new SearchContactTool(),
        new CreateEventTool(),
        new GetCurrentDateTool(),
        new CreateReminderTool(),
        new GetContactEventsTool(),
      ],
    });;
  }

  static getInstance(): MemoMateAssistant {
    if (!MemoMateAssistant.instance) {
      MemoMateAssistant.instance = new MemoMateAssistant();
    }
    return MemoMateAssistant.instance;
  }

  async init() {
    try {
      await this.agent.init();
      console.log("Asistente inicializado correctamente");
    } catch (error) {
      console.error("Error al inicializar el asistente:", error);
      throw error;
    }
  }

  async sendMessage(userId: string,threadId: string, message: string): Promise<string> {
    try {
      const thread = new Thread<ThreadMetadata>({
        id: threadId,
        agent: this.agent,
        metadata: {
          userId: userId,
        },
      });
      await thread.init();
      const response = await thread.send(message);
      return response;
    } catch (error) {
      if (error instanceof Error) {
        return error.message;
      }
      return "Error al enviar mensaje";
    }
  }
}
```

Una cosa a destacar es la inicializaci√≥n del agente. Como podemos ver, y en l√≠nea con lo que coment√°bamos en el punto anterior, el Asistente ya lo tenemos creado y contamos con su id en OpenAI, el cual mantenemos en una variable de entorno para que directamente se recupere y, si es necesario, se actualice.

### Conectar Bot con Asistente. Clase MemoMateProcessor

Una vez tenemos el asistente ya configurado, el siguiente paso es conectarlo al bot de Telegram para que el usuario pueda interactuar con √©l. Aqu√≠ es donde entra en juego la clase `MemoMateProcessor`. Esta clase se encarga de definir m√©todos para ser ejecutados en diferentes eventos que el bot de Telegram nos emita, como cuando el usuario inicia una nueva conversaci√≥n, o cuando env√≠a un mensaje. Para cada una de estas acciones, creamos un m√©todo en esta clase que lo gestione. Por ejemplo, cuando el usuario dispare el comando `/help`, haremos que se ejecute el m√©todo `handleHelp` de esta clase:

```
  public async handleHelp(ctx: Context) {
    const message = helpTemplate();
    ctx.reply(message, {
      parse_mode: 'HTML'
    });
  }
```

Este m√©todo simplemente define un html con el mensaje que le queremos dar al usuario, en este caso con la ayuda de como usar el bot. A trav√©s de objeto Context, respondemos al usuario enviando dicho mensaje en formato html.

El m√©todo m√°s interesante en esta clase es el `handleMessage`, que ser√° el que se ejecute con cada nuevo mensaje del usuario. Vamos a ver un poco lo que se hace aqu√≠.

```tsx
  public async handleMessage(ctx: TextMessageContext) {
    try {
      const telegramUserId = ctx.message.from.id;
      const chatId = ctx.message.chat.id;
      const message = ctx.message.text;
  
      const user = await this._getOrCreateUser(telegramUserId, chatId);
  
      const canSend = user.stripeSubscriptionId || user.credits > 0;
      
      if (!canSend) {
        const link = await this.createSessionUrl(user.id);
        ctx.reply(limitMessageTemplate(link), {
          parse_mode: 'HTML'
        });
        return;
      }

      await prisma.messageLog.create({
        data: {
          userId: user.id,
          message: message,
          direction: MessageLogDirection.INCOMING,
        }
      });

      const response = await this.assistant.sendMessage(user.id, user.openaiThreadId, message);
      
      await prisma.messageLog.create({
        data: {
          userId: user.id,
          message: response,
          direction: MessageLogDirection.OUTGOING,
        }
      });
      
      if (!user.stripeSubscriptionId) {
        await prisma.user.update({
          where: { id: user.id },
          data: {
            credits: { decrement: 1 }
          }
        });
      }
      
      ctx.reply(response);
    } catch (error) {
      console.error(error);
    }
  }
```

En primer lugar, recuperamos a trav√©s del `Context` los datos que necesitamos para poder identificiar al usuario y el mensaje que nos env√≠a. Llamamos a un m√©todo privado `_getOrCreateUser` que se encarga de recuperar este usuario en nuestra base de datos, o de crearlo si no existiera.

> Es interesante ver la implementaci√≥n de este m√©todo `_getOrCreateUser`. Al crear el usuario tambi√©n creamos el Thread que nos permite abrir una nueva conversaci√≥n con el asistente. De esta forma ya tendremos todo listo para que este nuevo usuario pueda enviar mensajes al asistente.

El siguiente paso es analizar si el usuario puede enviar mensajes al asistente o no. Muy sencillo, podr√° enviar si es Premium o, en su defecto, si el n√∫mero de cr√©ditos es mayor que 0. Si no puede enviar, resolvemos este m√©todo enviando un mensaje est√°ndar que le sugiera al usuario ir a la plataforma Web para hacerse Premium.

En caso contrario, ya solo nos queda enviar el mensaje del usuario al asistente, a trav√©s del `sendMessage` del `MemoMateAssistant`. Si el usuario no es Premium, le restamos cr√©dito. Guardamos ambos mensajes (el del usuario y la respuesta) en un Log de mensajes. Y, finalmente, respondemos al usuario con la respuesta del asistente.

### Crons para recordatorios

Para manejar tanto los recordatorios como la renovaci√≥n de cr√©ditos de usuarios gratuitos, implementamos un sistema de tareas programadas usando la librer√≠a `cron`. Se cre√≥ una clase `CronManager` que gestiona dos trabajos principales:

1. **Procesamiento de Recordatorios**: Se ejecuta cada minuto para verificar si hay recordatorios pendientes que deban ser enviados a los usuarios. Cuando encuentra recordatorios cuya fecha de notificaci√≥n ha llegado, env√≠a un mensaje por Telegram al usuario correspondiente.

> El par√°metro `telegramChatId` que guardamos en el usuario cuando lo creamos es lo que necesitamos para poder enviar un mensaje a ese usuario en Telegram

```tsx
async processReminders() {
  const pendingReminders = await prisma.reminder.findMany({
    where: {
      completed: false,
      remindAt: {
        lte: new Date()
      }
    },
    include: {
      user: true,
      contact: true
    }
  });

  for (const reminder of pendingReminders) {
    let message = `üîî Recordatorio: ${reminder.message}`;
    if (reminder.contact) {
      message += `\nContacto: ${reminder.contact.name}`;
    }

    await this.bot.telegram.sendMessage(
      reminder.user.telegramChatId.toString(),
      message
    );
    
    await prisma.reminder.update({
      where: { id: reminder.id },
      data: { completed: true }
    });
  }
}
```

1. **Renovaci√≥n de Cr√©ditos**: Se ejecuta diariamente a las 3 AM para renovar los cr√©ditos de los usuarios gratuitos. Busca usuarios cuya fecha de renovaci√≥n haya llegado y les asigna nuevamente su cuota mensual de cr√©ditos:

```tsx
async renewCredits(): Promise<void> {
  const usersToRenew = await prisma.user.findMany({
    where: {
      stripeSubscriptionId: null,
      renewAt: {
        lt: new Date()
      }
    }
  });

  for (const user of usersToRenew) {
    await prisma.user.update({
      where: { id: user.id },
      data: {
        credits: DEFAULT_CREDITS,
        renewAt: addMonths(new Date(), 1)
      }
    });
  }
}
```

La implementaci√≥n actual es simple pero efectiva, aunque **tiene margen de mejora**. Por ejemplo, el procesamiento tanto de recordatorios como de renovaci√≥n de cr√©ditos se realiza de forma secuencial, lo que podr√≠a ser un problema si el n√∫mero de usuarios crece significativamente. Una mejora futura ser√≠a implementar un sistema de procesamiento por lotes para manejar grandes vol√∫menes de datos de manera m√°s eficiente.

### Pinecone para la b√∫squeda de contactos

Uno de los desaf√≠os m√°s interesantes fue implementar un sistema que permitiera al asistente identificar correctamente de qu√© contacto est√° hablando el usuario, incluso cuando la referencia no es exacta. Por ejemplo, si el usuario dice "mi amigo Juan de Madrid", el sistema debe ser capaz de encontrar el contacto correcto aunque est√© guardado como "Juan Garc√≠a".

Para lograr esto, implementamos b√∫squeda sem√°ntica utilizando Pinecone, una base de datos vectorial que nos permite buscar similitud entre textos. El proceso funciona as√≠:

1. **Indexaci√≥n de Contactos**: Cuando se crea o actualiza un contacto, generamos un embedding (una representaci√≥n vectorial del texto) que incluye toda la informaci√≥n relevante del contacto:

```tsx
      // Dentro de CreateContactTool
      
      // Generar el texto para el embedding
      const contactText = `Nombre: ${name}${relation ? `, Relaci√≥n: ${relation}` : ''}${location ? `, Ubicaci√≥n: ${location}` : ''}`;
      
      // Generar embedding usando OpenAI
      const embeddings = new Embeddings();
      const embeddingValue = await embeddings.generateEmbedding(contactText);
      
      // Indexar en Pinecone
      await PineconeService.getInstance().upsertContact(
        metadata.userId,
        contact.id,
        embeddingValue
      );
```

1. **B√∫squeda de Contactos**: Cuando el asistente necesita identificar un contacto, utiliza la herramienta `SearchContactTool` que convierte la consulta en un embedding y busca coincidencias en Pinecone:

```tsx
async run(parameters: SearchContactRunProps): Promise<string> {
  const searchText = `Nombre: ${name}${relation ? `, Relaci√≥n: ${relation}` : ''}${location ? `, Ubicaci√≥n: ${location}` : ''}`;
  
  const embeddings = new Embeddings();
  const queryEmbedding = await embeddings.generateEmbedding(searchText);
  
  const results = await PineconeService.getInstance().searchSimilarContacts(
    metadata.userId,
    queryEmbedding,
    1 // Solo necesitamos el m√°s similar
  );

  if (results.length > 0 && results[0].score && results[0].score > 0.7) {
    return `Contacto encontrado con ID: ${results[0].id}`;
  }
  return "No se encontr√≥ ning√∫n contacto que coincida...";
}
```

La implementaci√≥n se centraliza en la clase `PineconeService`, que maneja toda la interacci√≥n con Pinecone:

```tsx
export class PineconeService {
  private indexName = 'memomate-contacts';
  private dimension = 1024;

  async init() {
    try {
      const pinecone = getPineconeClient();
      
      // Verificar si el √≠ndice existe
      const existingIndexes = await pinecone.listIndexes();
      
      const indexExists = existingIndexes?.indexes?.some(
        (index: IndexModel) => index.name === this.indexName
      );
      
      if (!indexExists) {
        // Crear el √≠ndice si no existe
        await pinecone.createIndex({
          name: this.indexName,
          dimension: this.dimension,
          metric: 'cosine',
          spec: {
            serverless: {
              cloud: 'aws',
              region: 'us-east-1'
            }
          },
        });
        
        console.log('√çndice de Pinecone creado correctamente');
      }
    } catch (error) {
      console.error('Error al inicializar Pinecone:', error);
      throw error;
    }
  }

  async searchSimilarContacts(userId: string, queryEmbedding: number[], limit: number = 5) {
    try {
      const pinecone = getPineconeClient();
      const index = pinecone.index(this.indexName);

      const results = await index.query({
        vector: queryEmbedding,
        filter: {
          userId: userId
        },
        topK: limit,
        includeMetadata: true
      });

      return results.matches;
    } catch (error) {
      console.error('Error al buscar contactos similares:', error);
      return [];
    }
  }
}
```

Esta implementaci√≥n nos permite una b√∫squeda "fuzzy" de contactos que va m√°s all√° de la coincidencia exacta de texto. El sistema entiende el contexto y las relaciones sem√°nticas, permitiendo que el asistente identifique correctamente los contactos incluso cuando el usuario los menciona de forma informal o incompleta.

### Web en Next

Hasta aqu√≠ hemos visto todo lo que tiene que ver con el bot o la integraci√≥n con OpenAI. Vamos a ver ahora muy brevemente la implementaci√≥n que hemos hecho en el lado de la Web.

La aplicaci√≥n Web de MemoMate se implement√≥ utilizando Next.js 14, aprovechando sus Server Components y con el App Router. Se trata de una implementaci√≥n relativamente sencilla que sirve como complemento al bot de Telegram, permitiendo a los usuarios gestionar su cuenta y visualizar sus datos de una forma m√°s estructurada.

La web consta de las siguientes secciones principales:

* **Landing Page**: Una p√°gina de inicio atractiva que presenta el producto, sus caracter√≠sticas principales y ejemplos de uso. Implementada con componentes interactivos y un dise√±o moderno usando Tailwind. Anima al usuario a acceder al bot y, cuando detecta que el usuario est√° autenticado, le muestra un enlace para acceder a su dashboard.
* **Dashboard**: Muestra un resumen de la actividad del usuario, incluyendo estad√≠sticas sobre sus contactos y uso del bot
* **Contactos**: Permite ver, editar y eliminar contactos, as√≠ como importar contactos mediante CSV
* **Eventos**: Visualizaci√≥n y gesti√≥n de los eventos registrados para cada contacto
* **Suscripci√≥n**: Panel para gestionar la suscripci√≥n Premium mediante Stripe

Lo m√°s interesante de la implementaci√≥n web es su mecanismo de autenticaci√≥n, que ya explicamos anteriormente. En lugar de un sistema tradicional de login/registro, la autenticaci√≥n se realiza a trav√©s del bot de Telegram, que genera links temporales de acceso. Este enfoque no solo simplifica la experiencia del usuario sino que tambi√©n refuerza la integraci√≥n entre el bot y la web.

La UI se construy√≥ utilizando Tailwind CSS junto con los componentes de Shadcn/ui, lo que nos permiti√≥ crear una interfaz moderna y responsive de forma r√°pida y mantenible.

Al ser una implementaci√≥n bastante est√°ndar de Next.js, no profundizaremos m√°s en los detalles t√©cnicos. El c√≥digo fuente est√° disponible en el repositorio para aquellos interesados en explorar la implementaci√≥n completa.

### Suscripciones con Stripe

La gesti√≥n de suscripciones es una parte fundamental de MemoMate, ya que determina el acceso a las funcionalidades Premium. Implementamos un sistema de suscripciones usando Stripe, que es gestionado desde la plataforma Web y que se reflejan en la base de datos para que el bot pueda saber si un usuario es Premium o no y actuar en consecuencia.

#### Interfaz de Suscripci√≥n

La p√°gina de suscripci√≥n proporciona una interfaz clara para que los usuarios gestionen su plan. Controlar√° si el usuario tiene una suscripci√≥n activa o no, mostr√°ndole la UI correspondiente. En cualquier caso, podr√° gestionar su suscripci√≥n, tanto para activarla como para cancelarla, siempre redireccionando al checkout de Stripe.

#### Integraci√≥n con el Bot

El bot, en el `MemoMateProcessor`, verifica el estado de la suscripci√≥n antes de procesar cada mensaje:

```tsx
public async handleMessage(ctx: TextMessageContext) {

  // 

  const user = await this._getOrCreateUser(telegramUserId, chatId);

  // Verificar si el usuario puede enviar mensajes
  const canSend = user.stripeSubscriptionId || user.credits > 0;
  
  if (!canSend) {
    const link = await this.createSessionUrl(user.id);
    ctx.reply(limitMessageTemplate(link), {
      parse_mode: 'HTML'
    });
    return;
  }
  
  // Procesar el mensaje...
}
```

#### Webhooks de Stripe

Para mantener sincronizado el estado de la suscripci√≥n, implementamos un webhook que procesa los eventos de Stripe. Esta es la forma que tenemos de enterarnos si el usuario decida cancelar la suscripci√≥n y, en consecuencia, debemos eliminar el Premium en el usuario. Desde ese momento le asignamos los cr√©ditos iniciales y le marcamos la fecha de renovaci√≥n dentro de un mes.

```tsx
export default async function StripeWebhookRoute(req: Request) {
  try {
    const body = await req.text();
    const signature = req.headers.get("stripe-signature")!;
    const event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    );

    if (event.type === "customer.subscription.deleted" || 
        event.type === "customer.subscription.updated") {
      const subscription = event.data.object as Stripe.Subscription;
      
      if (subscription.status !== "active") {
        await prisma.user.updateMany({
          where: {
            stripeSubscriptionId: subscription.id as string,
          },
          data: {
            stripeSubscriptionId: null,
            renewAt: addMonths(new Date(), 1),
            credits: DEFAULT_CREDITS,
          },
        });
      }
    }

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error(error);
    if (error instanceof CustomError) return apiError(error);
    return apiError(
      new CustomError({
        message: "Error interno del servidor",
        statusCode: 500,
      }),
    );
  }
} 
```

En resumen, este sistema nos permite:

1. **Gesti√≥n Transparente**: Los usuarios pueden gestionar su suscripci√≥n f√°cilmente desde la web
2. **Actualizaci√≥n Autom√°tica**: El estado de la suscripci√≥n se actualiza autom√°ticamente en la base de datos cuando ocurren eventos en Stripe
3. **Control de Acceso**: El bot verifica el estado de la suscripci√≥n antes de procesar cada mensaje
4. **Degradaci√≥n Graciosa**: Cuando un usuario cancela su suscripci√≥n, vuelve autom√°ticamente al plan gratuito con sus cr√©ditos mensuales

### Mejoras Futuras y Conclusi√≥n

Durante el desarrollo de MemoMate, han surgido varias ideas para mejoras futuras que podr√≠an enriquecer a√∫n m√°s la experiencia:

1. **Procesamiento en Lotes**: Implementar un sistema de procesamiento por lotes para manejar recordatorios y renovaciones de cr√©ditos de forma m√°s eficiente.
2. **Integraci√≥n con M√°s Plataformas**: Expandir m√°s all√° de Telegram, a√±adiendo soporte para WhatsApp o Discord.
3. **Mejoras en la B√∫squeda**: Refinar el sistema de b√∫squeda sem√°ntica para obtener resultados a√∫n m√°s precisos.

Tambi√©n es importante destacar que el proyecto es puramente educativo. Por eso no hemos mencionado nada acerca de despliegues o puesta en producci√≥n. Si alguien ve interesante este proyecto y quiere llevar a cabo las acciones necesarias para poner en marcha este producto en el mercado, que no dude en contactarme üòâ

El desarrollo de MemoMate ha sido un viaje fascinante que me ha permitido explorar y combinar diferentes tecnolog√≠as modernas. Desde la integraci√≥n con OpenAI hasta la implementaci√≥n de b√∫squedas sem√°nticas con Pinecone, cada parte del proyecto ha presentado sus propios desaf√≠os y aprendizajes.

Si te ha interesado este proyecto y quieres saber m√°s, puedes encontrarme en:

* Twitter: [@enolcasielles](https://twitter.com/enolcasielles)
* LinkedIn: [Enol Casielles](https://www.linkedin.com/in/enol-casielles-martinez-2a848864/)
* Email: [enolcasielles@gmail.com](mailto\:enolcasielles@gmail.com)

Tambi√©n dejo por aqu√≠ de nuevo el [c√≥digo completo en GitHub](https://github.com/enolcasielles/memo-mate) para que lo puedas explorar y probar.

¬°Espero que este art√≠culo te haya resultado √∫til e interesante! Si tienes cualquier duda, sugerencia o simplemente quieres compartir tu experiencia, estar√© encantado de escucharte. üöÄ